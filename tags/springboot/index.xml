<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>SpringBoot on Cheney Site</title>
        <link>https://cheneycqg.github.io/tags/springboot/</link>
        <description>Recent content in SpringBoot on Cheney Site</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>zh-cn</language>
        <lastBuildDate>Sun, 06 Aug 2023 00:00:00 +0000</lastBuildDate><atom:link href="https://cheneycqg.github.io/tags/springboot/index.xml" rel="self" type="application/rss+xml" /><item>
        <title>SpringBoot项目Validation组件&#43;全局异常处理进行各种参数验证问题</title>
        <link>https://cheneycqg.github.io/post/validation/</link>
        <pubDate>Sun, 06 Aug 2023 00:00:00 +0000</pubDate>
        
        <guid>https://cheneycqg.github.io/post/validation/</guid>
        <description>&lt;img src="https://cheneycqg.github.io/post/validation/1.jpg" alt="Featured image of post SpringBoot项目Validation组件&#43;全局异常处理进行各种参数验证问题" /&gt;&lt;p&gt;SpringBoot项目Validation组件+全局异常处理进行各种参数验证问题，比如，写登录模块各种条件的判断等等&lt;/p&gt;
&lt;h1 id=&#34;springboot&#34;&gt;SpringBoot&lt;/h1&gt;
&lt;h2 id=&#34;为什么要使用validation组件和valid进行参数验证&#34;&gt;为什么要使用Validation组件和@Valid进行参数验证&lt;/h2&gt;
&lt;p&gt;SpringBoot项目中，会经常写接口类，比如：登录或者注册模块会有大量的校验工作。在写接口时经常要写效验请求参数逻辑，这时候我们会常用做法是写大量的 if 与 if else 类似这样的代码来做判断，如下：
&lt;img src=&#34;https://cheneycqg.github.io/post/validation/2.jpg&#34;
	width=&#34;1049&#34;
	height=&#34;261&#34;
	srcset=&#34;https://cheneycqg.github.io/post/validation/2_hufe4874d73f05ef0d0987cf6aad4786d8_31961_480x0_resize_q75_box.jpg 480w, https://cheneycqg.github.io/post/validation/2_hufe4874d73f05ef0d0987cf6aad4786d8_31961_1024x0_resize_q75_box.jpg 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;2&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;401&#34;
		data-flex-basis=&#34;964px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;这样的代码如果按正常代码逻辑来说，是没有什么问题的，不过按优雅来说，简直糟糕透了。不仅不优雅，而且如果存在大量的验证逻辑，这会使代码看起来乱糟糟，大大降低代码可读性，那么有没有更好的方法能够简化这个过程呢？&lt;/p&gt;
&lt;p&gt;答案当然是有，推荐的是使用 @Valid 注解来帮助我们简化验证逻辑。&lt;/p&gt;
&lt;h2 id=&#34;valid的相关注解&#34;&gt;@Valid的相关注解&lt;/h2&gt;
&lt;p&gt;下面是 @Valid 相关的注解，在实体类中不同的属性上添加不同的注解，就能实现不同数据的效验功能。
&lt;img src=&#34;https://cheneycqg.github.io/post/validation/3.png&#34;
	width=&#34;681&#34;
	height=&#34;549&#34;
	srcset=&#34;https://cheneycqg.github.io/post/validation/3_hub013f0394bfe45497f19d50c43878bfa_80449_480x0_resize_box_3.png 480w, https://cheneycqg.github.io/post/validation/3_hub013f0394bfe45497f19d50c43878bfa_80449_1024x0_resize_box_3.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;3&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;124&#34;
		data-flex-basis=&#34;297px&#34;
	
&gt;&lt;/p&gt;
&lt;h2 id=&#34;使用valid进行参数校验步骤&#34;&gt;使用@Valid进行参数校验步骤&lt;/h2&gt;
&lt;p&gt;整个过程如下图所示，用户访问接口，然后进行参数效验，因为 @Valid 不支持平面的参数效验（直接写在参数中字段的效验）所以基于 GET 请求的参数还是按照原先方式进行效验，而 POST 则可以以实体对象为参数，可以使用 @Valid 方式进行效验。如果效验通过，则进入业务逻辑，否则抛出异常，交由全局异常处理器进行处理。&lt;/p&gt;
&lt;h2 id=&#34;springboot实战&#34;&gt;SpringBoot实战&lt;/h2&gt;
&lt;h3 id=&#34;valid&#34;&gt;@Valid&lt;/h3&gt;
&lt;h4 id=&#34;实体类&#34;&gt;实体类&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;	package com.cheney.seckill.vo;

	import com.cheney.seckill.validation.IsMobile;
	import lombok.AllArgsConstructor;
	import lombok.Data;
	import lombok.NoArgsConstructor;
	import org.hibernate.validator.constraints.Length;

	import javax.validation.constraints.NotNull;

	@Data
	@AllArgsConstructor
	@NoArgsConstructor
	public class LoginVo {

		@IsMobile(require = true)
		private String mobile;
		@NotNull
		@Length(min = 32,max = 32)
		private String password;
	}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;controller&#34;&gt;Controller&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;	@Controller
	@RequestMapping(&amp;quot;/login&amp;quot;)
	public class LoginController {
		@Autowired
		private IUserService iUserService;
		@RequestMapping(&amp;quot;/toLogin&amp;quot;)
		public String toLogin(){
    		return &amp;quot;login&amp;quot;;
		}
	@RequestMapping(&amp;quot;/doLogin&amp;quot;)
	@ResponseBody
	public RespBean doLogin(@Valid LoginVo loginVo, HttpServletRequest request, HttpServletResponse response) throws InterruptedException {
    	RespBean respBean = iUserService.doLogin(loginVo,request,response);
    	Thread.sleep(2000);
    	return respBean;
		}
	}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;注意： 形参上必须要加@Valid注解&lt;/p&gt;
&lt;h4 id=&#34;进行测试&#34;&gt;进行测试&lt;/h4&gt;
&lt;h3 id=&#34;自定义校验&#34;&gt;自定义校验&lt;/h3&gt;
&lt;h4 id=&#34;引入validation组件依赖&#34;&gt;引入validation组件依赖&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;!-- validation组件 --&amp;gt; 
&amp;lt;dependency&amp;gt;
	&amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
	&amp;lt;artifactId&amp;gt;spring-boot-starter-validation&amp;lt;/artifactId&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;自定义校验注解&#34;&gt;自定义校验注解&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;/**
* 验证手机号
*/
@Target({METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER, TYPE_USE})
@Retention(RUNTIME)
@Documented
@Constraint(validatedBy = {IsMobileValidator.class})
public @interface IsMobile {
   boolean required() default true;
   String message() default &amp;quot;手机号码格式错误&amp;quot;;
   Class&amp;lt;?&amp;gt;[] groups() default {};
   Class&amp;lt;? extends Payload&amp;gt;[] payload() default {};
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;自定义校验注解的校验器&#34;&gt;自定义校验注解的校验器&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;/**
 * 自定义IsMobile注解的校验器
 */
public class IsMobileValidator implements ConstraintValidator&amp;lt;IsMobile,String&amp;gt; {
	private boolean require;
	@Override
	public void initialize(IsMobile constraintAnnotation) {
		require = constraintAnnotation.require();
	}

	@Override
	public boolean isValid(String s, ConstraintValidatorContext constraintValidatorContext) {
		//判断require是否符合手机格式
		if (StringUtils.isEmpty(s)){
			if (require)
			//手机号为空。要求必填
				return false;
			else
			//手机号为空，但是我也不要求必填
				return true;
		}else {
			//1手机号不为空
			return ValidatorUtil.isMobile(s);
		}
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;自定义校验规则&#34;&gt;自定义校验规则&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;/**
* 校验工具类
*/
public class ValidatorUtil {
	private static final Pattern mobile_pattern = Pattern.compile(&amp;quot;[1]([3-9])[0-9]{9}$&amp;quot;);
    public static boolean isMobile(String mobile){
  		if (StringUtils.isEmpty(mobile)) {
 			return false;
  		}
  		Matcher matcher = mobile_pattern.matcher(mobile);
  		return matcher.matches();
   }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;异常处理&#34;&gt;异常处理&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;我们知道，系统中异常包括：编译时异常和运行时异常 RuntimeException ，前者通过捕获异常从而获 取异常信息，后者主要通过规范代码开发、测试通过手段减少运行时异常的发生。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在开发中，不管是 dao层、service层还是controller层，都有可能抛出异常，在Springmvc中，能将所有类型的异常处理,从各处理过程解耦出来，既保证了相关处理过程的功能较单一，也实现了异常信息的统一处理和维护。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;SpringBoot全局异常处理方式主要两种：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使用 @ControllerAdvice 和 @ExceptionHandler 注解。&lt;/li&gt;
&lt;li&gt;使用 ErrorController类 来实现&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;区别：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;@ControllerAdvice 方式只能处理控制器抛出的异常。此时请求已经进入控制器中。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;ErrorController类 方式可以处理所有的异常，包括未进入控制器的错误，比如404,401等错误&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果应用中两者共同存在，则 @ControllerAdvice 方式处理控制器抛出的异常,ErrorController类 方式处理未进入控制器的异常。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;@ControllerAdvice 方式可以定义多个拦截方法，拦截不同的异常类，并且可以获取抛出的异常 信息，自由度更大。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;globalexception&#34;&gt;&lt;strong&gt;GlobalException&lt;/strong&gt;&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;/**
 * 自定义全局异常
 * 我们抛出的所有异常都是该异常
 */
@Data
@AllArgsConstructor
@NoArgsConstructor
public class GlobalException extends RuntimeException{
	private RespBeanEnum respBeanEnum;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;globalexceptionhandler&#34;&gt;&lt;strong&gt;GlobalExceptionHandler&lt;/strong&gt;&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;/**
 * 全局异常处理器
 */
@RestControllerAdvice
public class GlobalExceptionHandler {
@ExceptionHandler(value = Exception.class)
public RespBean handler(Exception e) throws Exception {
	//将异常转换为RespBean对象
	//异常有很多种。可能是自己的异常，可能是系统的等等
	if (e instanceof GlobalException){
		GlobalException ge = (GlobalException) e;
		return RespBean.error(ge.getRespBeanEnum());
	}else if (e instanceof BindException){
		BindException be = (BindException) e;
		String msg = be.getBindingResult().getAllErrors().get(0).getDefaultMessage();
		return new RespBean(500502L,msg,null);
	}else {
		//throw e;
		return RespBean.error(RespBeanEnum.ERROR);
	}
}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这样就可以省去各种健壮性判断，并且通过全局异常来前端异常提示，而不是一个异常页面。但是对开发中调试bug不太友好，因为没有异常信息。&lt;/p&gt;</description>
        </item>
        
    </channel>
</rss>
