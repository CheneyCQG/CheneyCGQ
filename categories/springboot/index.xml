<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>SpringBoot on Cheney Site</title>
        <link>https://cheneycqg.github.io/categories/springboot/</link>
        <description>Recent content in SpringBoot on Cheney Site</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>zh-cn</language>
        <lastBuildDate>Mon, 14 Aug 2023 00:00:00 +0000</lastBuildDate><atom:link href="https://cheneycqg.github.io/categories/springboot/index.xml" rel="self" type="application/rss+xml" /><item>
        <title>自定义参数解析器，通过SpringMVC自动注入，判断频繁验证问题！如：用户是否登录问题</title>
        <link>https://cheneycqg.github.io/post/handlermethodargumentresolver/</link>
        <pubDate>Mon, 14 Aug 2023 00:00:00 +0000</pubDate>
        
        <guid>https://cheneycqg.github.io/post/handlermethodargumentresolver/</guid>
        <description>&lt;img src="https://cheneycqg.github.io/1.jpg" alt="Featured image of post 自定义参数解析器，通过SpringMVC自动注入，判断频繁验证问题！如：用户是否登录问题" /&gt;&lt;p&gt;自定义参数解析器，通过SpringMVC自动注入，判断频繁验证问题！如：用户是否登录问题&lt;/p&gt;
&lt;h1 id=&#34;springboot&#34;&gt;SpringBoot&lt;/h1&gt;
&lt;h2 id=&#34;参数解析器介绍&#34;&gt;参数解析器介绍&lt;/h2&gt;
&lt;p&gt;参数解析器属于spring-web包中提供的组件，springmvc框架中对应提供了很多参数解析器。例如我们开发的Controller代码如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@RestController
@RequestMapping(&amp;quot;/user&amp;quot;)
public class UserController{
	@PostMapping(&amp;quot;/save&amp;quot;)
	//此处request对象就是通过Springmvc提供的参数解析器帮我们注入的
	public String saveUser(HttpServletRequest request){
    	return &amp;quot;success&amp;quot;;
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在上面的saveUser方法中，我们声明了一个类型为HttpServletRequest的参数，这个对象就是通过springmvc提供的ServletRequestMethodArgumentResolver这个参数解析器帮我们注入的。同样如果我们需要使用HttpServletResponse对象，也可以直接在方法上加入这个参数即可，此时springmvc会通过ServletResponseMethodArgumentResolver这个参数解析器帮我们注入。&lt;/p&gt;
&lt;p&gt;在项目开发中我们也可以根据需要自定义参数解析器，需要实现HandlerMethodArgumentResolver接口：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public interface HandlerMethodArgumentResolver {
	boolean supportsParameter(MethodParameter var1);

	@Nullable
	Object resolveArgument(MethodParameter var1, 
                        @Nullable ModelAndViewContainer var2, 
                        NativeWebRequest var3, 
                        @Nullable WebDataBinderFactory var4) throws Exception;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可以看到此接口包含两个接口方法：supportsParameter和resolveArgument。&lt;/p&gt;
&lt;p&gt;当supportsParameter方法返回true时，才会调用resolveArgument方法。&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;http://t.csdn.cn/xtvDj&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;自定义参数解析器的使用总结&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;springboot实战&#34;&gt;SpringBoot实战&lt;/h2&gt;
&lt;h3 id=&#34;案例goodscontroller判断用户是否登录&#34;&gt;案例：GoodsController判断用户是否登录&lt;/h3&gt;
&lt;h4 id=&#34;实体类&#34;&gt;实体类&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;@Data
@EqualsAndHashCode(callSuper = false)
@TableName(&amp;quot;t_user&amp;quot;)
public class User implements Serializable {
	private static final long serialVersionUID = 1L;
    /**
     * 用户ID,手机号码
     */
    private Long id;	
    private String nickname;	
    /**
     * MD5(MD5(pass明文+固定salt)+salt)
     */
    private String password;

    private String salt;
    /**
     * 头像
     */
    private String head;	
    /**
     * 注册时间
     */
    private Date registerDate;	
    /**
     * 最后一次登录事件
     */
    private Date lastLoginDate;	
    /**
     * 登录次数
     */
    private Integer loginCount;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;controller&#34;&gt;Controller&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;@Controller
@RequestMapping(&amp;quot;/goods&amp;quot;)
public class GoodsController {
    @Autowired
    private ISeckillGoodsService iSeckillGoodsService;
    @Autowired
    private RedisTemplate&amp;lt;String,Object&amp;gt; redisTemplate;
    @RequestMapping(&amp;quot;/toList&amp;quot;)
    public String toList(User user, Model model, HttpServletRequest request){
        //1判断用户是否登录
        if (user == null)
            return &amp;quot;login&amp;quot;;
        model.addAttribute(&amp;quot;user&amp;quot;,user);
        //2查询所有秒杀商品信息
        List&amp;lt;SeckillGoodsVo&amp;gt; list = iSeckillGoodsService.tolist();
        model.addAttribute(&amp;quot;goodsVoList&amp;quot;,list);
        return &amp;quot;goodsList&amp;quot;;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在形参上写上User，这样SpringMVC就可以自动注入，将验证后的User返回，只需要判断User是否为null即可。&lt;/p&gt;
&lt;h4 id=&#34;引入依赖&#34;&gt;引入依赖&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;dependency&amp;gt;
	&amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
	&amp;lt;artifactId&amp;gt;spring-boot-starter-web&amp;lt;/artifactId&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;自定义mvcconfig实现webmvcconfigurer接口&#34;&gt;自定义MVCConfig实现WebMvcConfigurer接口&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;@Component
public class MVCConfig implements WebMvcConfigurer {
	@Autowired
	private UserArgumentResolver userArgumentResolver;
	/**
 	* SpringMVC 提供的Controller的参数解析器
 	* @param resolvers
 	*/
	@Override
	public void addArgumentResolvers(List&amp;lt;HandlerMethodArgumentResolver&amp;gt; resolvers) {
    	boolean add = resolvers.add(userArgumentResolver);
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;实现WebMvcConfigurer接口，重写addArgumentResolvers方法，就可以将自定义的参数解析器注入&lt;/p&gt;
&lt;h4 id=&#34;自定义userargumentresolver实现handlermethodargumentresolver接口&#34;&gt;自定义UserArgumentResolver实现HandlerMethodArgumentResolver接口&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;@Component
public class UserArgumentResolver implements HandlerMethodArgumentResolver {
    @Autowired
    private RedisTemplate&amp;lt;String,Object&amp;gt; redisTemplate;
    @Override
    public boolean supportsParameter(MethodParameter parameter) {
        return parameter.getParameterType() == User.class;
    }

    @Override
    public Object resolveArgument(MethodParameter parameter, ModelAndViewContainer mavContainer, NativeWebRequest webRequest, WebDataBinderFactory binderFactory) throws Exception {
        HttpServletRequest request = webRequest.getNativeRequest(HttpServletRequest.class);
        String uuid = CookieUtil.getCookieValue(request, &amp;quot;token&amp;quot;);
        if (StringUtils.isEmpty(uuid)){
            return null;
        }
	//        Object users = request.getSession().getAttribute(uuid);
	//        if (users == null)
	//            return &amp;quot;login&amp;quot;;
    	String userJson = (String) redisTemplate.opsForValue().get(&amp;quot;user:uuid:&amp;quot; + uuid);
    	if (userJson == null)
        	return null;
    	User user = JsonUtil.jsonStr2Object(userJson, User.class);
    	return user;
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;最后将判断后的User返回，Controller中就可以拿到判断后的User了。&lt;/p&gt;</description>
        </item>
        <item>
        <title>SpringBoot项目Validation组件&#43;全局异常处理进行各种参数验证问题</title>
        <link>https://cheneycqg.github.io/post/validation/</link>
        <pubDate>Sun, 06 Aug 2023 00:00:00 +0000</pubDate>
        
        <guid>https://cheneycqg.github.io/post/validation/</guid>
        <description>&lt;img src="https://cheneycqg.github.io/post/validation/1.jpg" alt="Featured image of post SpringBoot项目Validation组件&#43;全局异常处理进行各种参数验证问题" /&gt;&lt;p&gt;SpringBoot项目Validation组件+全局异常处理进行各种参数验证问题，比如，写登录模块各种条件的判断等等&lt;/p&gt;
&lt;h1 id=&#34;springboot&#34;&gt;SpringBoot&lt;/h1&gt;
&lt;h2 id=&#34;为什么要使用validation组件和valid进行参数验证&#34;&gt;为什么要使用Validation组件和@Valid进行参数验证&lt;/h2&gt;
&lt;p&gt;SpringBoot项目中，会经常写接口类，比如：登录或者注册模块会有大量的校验工作。在写接口时经常要写效验请求参数逻辑，这时候我们会常用做法是写大量的 if 与 if else 类似这样的代码来做判断，如下：
&lt;img src=&#34;https://cheneycqg.github.io/post/validation/2.jpg&#34;
	width=&#34;1049&#34;
	height=&#34;261&#34;
	srcset=&#34;https://cheneycqg.github.io/post/validation/2_hufe4874d73f05ef0d0987cf6aad4786d8_31961_480x0_resize_q75_box.jpg 480w, https://cheneycqg.github.io/post/validation/2_hufe4874d73f05ef0d0987cf6aad4786d8_31961_1024x0_resize_q75_box.jpg 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;2&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;401&#34;
		data-flex-basis=&#34;964px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;这样的代码如果按正常代码逻辑来说，是没有什么问题的，不过按优雅来说，简直糟糕透了。不仅不优雅，而且如果存在大量的验证逻辑，这会使代码看起来乱糟糟，大大降低代码可读性，那么有没有更好的方法能够简化这个过程呢？&lt;/p&gt;
&lt;p&gt;答案当然是有，推荐的是使用 @Valid 注解来帮助我们简化验证逻辑。&lt;/p&gt;
&lt;h2 id=&#34;valid的相关注解&#34;&gt;@Valid的相关注解&lt;/h2&gt;
&lt;p&gt;下面是 @Valid 相关的注解，在实体类中不同的属性上添加不同的注解，就能实现不同数据的效验功能。
&lt;img src=&#34;https://cheneycqg.github.io/post/validation/3.png&#34;
	width=&#34;681&#34;
	height=&#34;549&#34;
	srcset=&#34;https://cheneycqg.github.io/post/validation/3_hub013f0394bfe45497f19d50c43878bfa_80449_480x0_resize_box_3.png 480w, https://cheneycqg.github.io/post/validation/3_hub013f0394bfe45497f19d50c43878bfa_80449_1024x0_resize_box_3.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;3&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;124&#34;
		data-flex-basis=&#34;297px&#34;
	
&gt;&lt;/p&gt;
&lt;h2 id=&#34;使用valid进行参数校验步骤&#34;&gt;使用@Valid进行参数校验步骤&lt;/h2&gt;
&lt;p&gt;整个过程如下图所示，用户访问接口，然后进行参数效验，因为 @Valid 不支持平面的参数效验（直接写在参数中字段的效验）所以基于 GET 请求的参数还是按照原先方式进行效验，而 POST 则可以以实体对象为参数，可以使用 @Valid 方式进行效验。如果效验通过，则进入业务逻辑，否则抛出异常，交由全局异常处理器进行处理。&lt;/p&gt;
&lt;h2 id=&#34;springboot实战&#34;&gt;SpringBoot实战&lt;/h2&gt;
&lt;h3 id=&#34;valid&#34;&gt;@Valid&lt;/h3&gt;
&lt;h4 id=&#34;实体类&#34;&gt;实体类&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;	package com.cheney.seckill.vo;

	import com.cheney.seckill.validation.IsMobile;
	import lombok.AllArgsConstructor;
	import lombok.Data;
	import lombok.NoArgsConstructor;
	import org.hibernate.validator.constraints.Length;

	import javax.validation.constraints.NotNull;

	@Data
	@AllArgsConstructor
	@NoArgsConstructor
	public class LoginVo {

		@IsMobile(require = true)
		private String mobile;
		@NotNull
		@Length(min = 32,max = 32)
		private String password;
	}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;controller&#34;&gt;Controller&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;	@Controller
	@RequestMapping(&amp;quot;/login&amp;quot;)
	public class LoginController {
		@Autowired
		private IUserService iUserService;
		@RequestMapping(&amp;quot;/toLogin&amp;quot;)
		public String toLogin(){
    		return &amp;quot;login&amp;quot;;
		}
	@RequestMapping(&amp;quot;/doLogin&amp;quot;)
	@ResponseBody
	public RespBean doLogin(@Valid LoginVo loginVo, HttpServletRequest request, HttpServletResponse response) throws InterruptedException {
    	RespBean respBean = iUserService.doLogin(loginVo,request,response);
    	Thread.sleep(2000);
    	return respBean;
		}
	}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;注意： 形参上必须要加@Valid注解&lt;/p&gt;
&lt;h4 id=&#34;进行测试&#34;&gt;进行测试&lt;/h4&gt;
&lt;h3 id=&#34;自定义校验&#34;&gt;自定义校验&lt;/h3&gt;
&lt;h4 id=&#34;引入validation组件依赖&#34;&gt;引入validation组件依赖&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;!-- validation组件 --&amp;gt; 
&amp;lt;dependency&amp;gt;
	&amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
	&amp;lt;artifactId&amp;gt;spring-boot-starter-validation&amp;lt;/artifactId&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;自定义校验注解&#34;&gt;自定义校验注解&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;/**
* 验证手机号
*/
@Target({METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER, TYPE_USE})
@Retention(RUNTIME)
@Documented
@Constraint(validatedBy = {IsMobileValidator.class})
public @interface IsMobile {
   boolean required() default true;
   String message() default &amp;quot;手机号码格式错误&amp;quot;;
   Class&amp;lt;?&amp;gt;[] groups() default {};
   Class&amp;lt;? extends Payload&amp;gt;[] payload() default {};
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;自定义校验注解的校验器&#34;&gt;自定义校验注解的校验器&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;/**
 * 自定义IsMobile注解的校验器
 */
public class IsMobileValidator implements ConstraintValidator&amp;lt;IsMobile,String&amp;gt; {
	private boolean require;
	@Override
	public void initialize(IsMobile constraintAnnotation) {
		require = constraintAnnotation.require();
	}

	@Override
	public boolean isValid(String s, ConstraintValidatorContext constraintValidatorContext) {
		//判断require是否符合手机格式
		if (StringUtils.isEmpty(s)){
			if (require)
			//手机号为空。要求必填
				return false;
			else
			//手机号为空，但是我也不要求必填
				return true;
		}else {
			//1手机号不为空
			return ValidatorUtil.isMobile(s);
		}
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;自定义校验规则&#34;&gt;自定义校验规则&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;/**
* 校验工具类
*/
public class ValidatorUtil {
	private static final Pattern mobile_pattern = Pattern.compile(&amp;quot;[1]([3-9])[0-9]{9}$&amp;quot;);
    public static boolean isMobile(String mobile){
  		if (StringUtils.isEmpty(mobile)) {
 			return false;
  		}
  		Matcher matcher = mobile_pattern.matcher(mobile);
  		return matcher.matches();
   }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;异常处理&#34;&gt;异常处理&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;我们知道，系统中异常包括：编译时异常和运行时异常 RuntimeException ，前者通过捕获异常从而获 取异常信息，后者主要通过规范代码开发、测试通过手段减少运行时异常的发生。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在开发中，不管是 dao层、service层还是controller层，都有可能抛出异常，在Springmvc中，能将所有类型的异常处理,从各处理过程解耦出来，既保证了相关处理过程的功能较单一，也实现了异常信息的统一处理和维护。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;SpringBoot全局异常处理方式主要两种：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使用 @ControllerAdvice 和 @ExceptionHandler 注解。&lt;/li&gt;
&lt;li&gt;使用 ErrorController类 来实现&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;区别：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;@ControllerAdvice 方式只能处理控制器抛出的异常。此时请求已经进入控制器中。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;ErrorController类 方式可以处理所有的异常，包括未进入控制器的错误，比如404,401等错误&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果应用中两者共同存在，则 @ControllerAdvice 方式处理控制器抛出的异常,ErrorController类 方式处理未进入控制器的异常。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;@ControllerAdvice 方式可以定义多个拦截方法，拦截不同的异常类，并且可以获取抛出的异常 信息，自由度更大。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;globalexception&#34;&gt;&lt;strong&gt;GlobalException&lt;/strong&gt;&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;/**
 * 自定义全局异常
 * 我们抛出的所有异常都是该异常
 */
@Data
@AllArgsConstructor
@NoArgsConstructor
public class GlobalException extends RuntimeException{
	private RespBeanEnum respBeanEnum;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;globalexceptionhandler&#34;&gt;&lt;strong&gt;GlobalExceptionHandler&lt;/strong&gt;&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;/**
 * 全局异常处理器
 */
@RestControllerAdvice
public class GlobalExceptionHandler {
@ExceptionHandler(value = Exception.class)
public RespBean handler(Exception e) throws Exception {
	//将异常转换为RespBean对象
	//异常有很多种。可能是自己的异常，可能是系统的等等
	if (e instanceof GlobalException){
		GlobalException ge = (GlobalException) e;
		return RespBean.error(ge.getRespBeanEnum());
	}else if (e instanceof BindException){
		BindException be = (BindException) e;
		String msg = be.getBindingResult().getAllErrors().get(0).getDefaultMessage();
		return new RespBean(500502L,msg,null);
	}else {
		//throw e;
		return RespBean.error(RespBeanEnum.ERROR);
	}
}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这样就可以省去各种健壮性判断，并且通过全局异常来前端异常提示，而不是一个异常页面。但是对开发中调试bug不太友好，因为没有异常信息。&lt;/p&gt;</description>
        </item>
        
    </channel>
</rss>
