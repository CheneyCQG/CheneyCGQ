<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>java on Cheney Site</title>
        <link>https://cheneycqg.github.io/categories/java/</link>
        <description>Recent content in java on Cheney Site</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>zh-cn</language>
        <lastBuildDate>Mon, 14 Aug 2023 00:00:00 +0000</lastBuildDate><atom:link href="https://cheneycqg.github.io/categories/java/index.xml" rel="self" type="application/rss+xml" /><item>
        <title>自定义参数解析器，通过SpringMVC自动注入，判断频繁验证问题！如：用户是否登录问题</title>
        <link>https://cheneycqg.github.io/post/handlermethodargumentresolver/</link>
        <pubDate>Mon, 14 Aug 2023 00:00:00 +0000</pubDate>
        
        <guid>https://cheneycqg.github.io/post/handlermethodargumentresolver/</guid>
        <description>&lt;img src="https://cheneycqg.github.io/post/handlermethodargumentresolver/1.png" alt="Featured image of post 自定义参数解析器，通过SpringMVC自动注入，判断频繁验证问题！如：用户是否登录问题" /&gt;&lt;p&gt;自定义参数解析器，通过SpringMVC自动注入，判断频繁验证问题！如：用户是否登录问题&lt;/p&gt;
&lt;h1 id=&#34;springboot&#34;&gt;SpringBoot&lt;/h1&gt;
&lt;h2 id=&#34;参数解析器介绍&#34;&gt;参数解析器介绍&lt;/h2&gt;
&lt;p&gt;参数解析器属于spring-web包中提供的组件，springmvc框架中对应提供了很多参数解析器。例如我们开发的Controller代码如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@RestController
@RequestMapping(&amp;quot;/user&amp;quot;)
public class UserController{
	@PostMapping(&amp;quot;/save&amp;quot;)
	//此处request对象就是通过Springmvc提供的参数解析器帮我们注入的
	public String saveUser(HttpServletRequest request){
    	return &amp;quot;success&amp;quot;;
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在上面的saveUser方法中，我们声明了一个类型为HttpServletRequest的参数，这个对象就是通过springmvc提供的ServletRequestMethodArgumentResolver这个参数解析器帮我们注入的。同样如果我们需要使用HttpServletResponse对象，也可以直接在方法上加入这个参数即可，此时springmvc会通过ServletResponseMethodArgumentResolver这个参数解析器帮我们注入。&lt;/p&gt;
&lt;p&gt;在项目开发中我们也可以根据需要自定义参数解析器，需要实现HandlerMethodArgumentResolver接口：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public interface HandlerMethodArgumentResolver {
	boolean supportsParameter(MethodParameter var1);

	@Nullable
	Object resolveArgument(MethodParameter var1, 
                        @Nullable ModelAndViewContainer var2, 
                        NativeWebRequest var3, 
                        @Nullable WebDataBinderFactory var4) throws Exception;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可以看到此接口包含两个接口方法：supportsParameter和resolveArgument。&lt;/p&gt;
&lt;p&gt;当supportsParameter方法返回true时，才会调用resolveArgument方法。&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;http://t.csdn.cn/xtvDj&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;自定义参数解析器的使用总结&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;springboot实战&#34;&gt;SpringBoot实战&lt;/h2&gt;
&lt;h3 id=&#34;案例goodscontroller判断用户是否登录&#34;&gt;案例：GoodsController判断用户是否登录&lt;/h3&gt;
&lt;h4 id=&#34;实体类&#34;&gt;实体类&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;@Data
@EqualsAndHashCode(callSuper = false)
@TableName(&amp;quot;t_user&amp;quot;)
public class User implements Serializable {
	private static final long serialVersionUID = 1L;
    /**
     * 用户ID,手机号码
     */
    private Long id;	
    private String nickname;	
    /**
     * MD5(MD5(pass明文+固定salt)+salt)
     */
    private String password;

    private String salt;
    /**
     * 头像
     */
    private String head;	
    /**
     * 注册时间
     */
    private Date registerDate;	
    /**
     * 最后一次登录事件
     */
    private Date lastLoginDate;	
    /**
     * 登录次数
     */
    private Integer loginCount;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;controller&#34;&gt;Controller&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;@Controller
@RequestMapping(&amp;quot;/goods&amp;quot;)
public class GoodsController {
    @Autowired
    private ISeckillGoodsService iSeckillGoodsService;
    @Autowired
    private RedisTemplate&amp;lt;String,Object&amp;gt; redisTemplate;
    @RequestMapping(&amp;quot;/toList&amp;quot;)
    public String toList(User user, Model model, HttpServletRequest request){
        //1判断用户是否登录
        if (user == null)
            return &amp;quot;login&amp;quot;;
        model.addAttribute(&amp;quot;user&amp;quot;,user);
        //2查询所有秒杀商品信息
        List&amp;lt;SeckillGoodsVo&amp;gt; list = iSeckillGoodsService.tolist();
        model.addAttribute(&amp;quot;goodsVoList&amp;quot;,list);
        return &amp;quot;goodsList&amp;quot;;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在形参上写上User，这样SpringMVC就可以自动注入，将验证后的User返回，只需要判断User是否为null即可。&lt;/p&gt;
&lt;h4 id=&#34;引入依赖&#34;&gt;引入依赖&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;dependency&amp;gt;
	&amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
	&amp;lt;artifactId&amp;gt;spring-boot-starter-web&amp;lt;/artifactId&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;自定义mvcconfig实现webmvcconfigurer接口&#34;&gt;自定义MVCConfig实现WebMvcConfigurer接口&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;@Component
public class MVCConfig implements WebMvcConfigurer {
	@Autowired
	private UserArgumentResolver userArgumentResolver;
	/**
 	* SpringMVC 提供的Controller的参数解析器
 	* @param resolvers
 	*/
	@Override
	public void addArgumentResolvers(List&amp;lt;HandlerMethodArgumentResolver&amp;gt; resolvers) {
    	boolean add = resolvers.add(userArgumentResolver);
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;实现WebMvcConfigurer接口，重写addArgumentResolvers方法，就可以将自定义的参数解析器注入&lt;/p&gt;
&lt;h4 id=&#34;自定义userargumentresolver实现handlermethodargumentresolver接口&#34;&gt;自定义UserArgumentResolver实现HandlerMethodArgumentResolver接口&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;@Component
public class UserArgumentResolver implements HandlerMethodArgumentResolver {
    @Autowired
    private RedisTemplate&amp;lt;String,Object&amp;gt; redisTemplate;
    @Override
    public boolean supportsParameter(MethodParameter parameter) {
        return parameter.getParameterType() == User.class;
    }

    @Override
    public Object resolveArgument(MethodParameter parameter, ModelAndViewContainer mavContainer, NativeWebRequest webRequest, WebDataBinderFactory binderFactory) throws Exception {
        HttpServletRequest request = webRequest.getNativeRequest(HttpServletRequest.class);
        String uuid = CookieUtil.getCookieValue(request, &amp;quot;token&amp;quot;);
        if (StringUtils.isEmpty(uuid)){
            return null;
        }
	//        Object users = request.getSession().getAttribute(uuid);
	//        if (users == null)
	//            return &amp;quot;login&amp;quot;;
    	String userJson = (String) redisTemplate.opsForValue().get(&amp;quot;user:uuid:&amp;quot; + uuid);
    	if (userJson == null)
        	return null;
    	User user = JsonUtil.jsonStr2Object(userJson, User.class);
    	return user;
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;最后将判断后的User返回，Controller中就可以拿到判断后的User了。&lt;/p&gt;</description>
        </item>
        <item>
        <title>02Java集合容器面试题</title>
        <link>https://cheneycqg.github.io/post/javacollectioncontainerinterviewquestions/</link>
        <pubDate>Wed, 09 Aug 2023 00:00:00 +0000</pubDate>
        
        <guid>https://cheneycqg.github.io/post/javacollectioncontainerinterviewquestions/</guid>
        <description>&lt;img src="https://cheneycqg.github.io/post/javacollectioncontainerinterviewquestions/1.jpg" alt="Featured image of post 02Java集合容器面试题" /&gt;&lt;p&gt;Java集合容器面试题主要包括：集合容器概述、Collection接口、Map接口、辅助工具类等方面的知识。&lt;/p&gt;
&lt;h1 id=&#34;java集合&#34;&gt;Java集合&lt;/h1&gt;
&lt;h2 id=&#34;集合容器概述&#34;&gt;集合容器概述&lt;/h2&gt;
&lt;h3 id=&#34;什么是集合&#34;&gt;什么是集合&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;集合框架&lt;/strong&gt; ：用于存储数据的容器。&lt;/p&gt;
&lt;p&gt;集合框架是为表示和操作集合而规定的一种统一的标准的体系结构。
任何集合框架都包含三大块内容：对外的接口、接口的实现和对集合运算的算法。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;接口&lt;/strong&gt; ：表示集合的抽象数据类型。接口允许我们操作集合时不必关注具体实现，从而达到&amp;quot;多态&amp;quot;。在面向对象编程语言中，接口通常用来形成规范。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;实现&lt;/strong&gt; ：集合接口的具体实现，是重用性很高的数据结构。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;算法&lt;/strong&gt; ：在一个实现了某个集合框架中的接口的对象身上完成某种有用的计算的方法，例如查找、排序等。这些算法通常是多态的，因为相同的方法可以在同一个接口被多个类实现时有不同的表现。事实上，算法是可复用的函数。
它减少了程序设计的辛劳。&lt;/p&gt;
&lt;p&gt;集合框架通过提供有用的数据结构和算法使你能集中注意力于你的程序的重要部分上，而不是为了让程序能正常运转而将注意力于低层设计上。
通过这些在无关API之间的简易的互用性，使你免除了为改编对象或转换代码以便联合这些API而去写大量的代码。 它提高了程序速度和质量。&lt;/p&gt;
&lt;h3 id=&#34;集合的特点&#34;&gt;集合的特点&lt;/h3&gt;
&lt;p&gt;集合的特点主要有如下两点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;对象封装数据，对象多了也需要存储。集合用于存储对象。&lt;/li&gt;
&lt;li&gt;对象的个数确定可以使用数组，对象的个数不确定的可以用集合。因为集合是可变长度的。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;集合和数组的区别&#34;&gt;集合和数组的区别&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;数组是固定长度的；集合可变长度的。&lt;/li&gt;
&lt;li&gt;数组可以存储基本数据类型，也可以存储引用数据类型；集合只能存储引用数据类型。&lt;/li&gt;
&lt;li&gt;数组存储的元素必须是同一个数据类型；集合存储的对象可以是不同数据类型。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;数据结构&lt;/strong&gt; ：就是容器中存储数据的方式。&lt;/p&gt;
&lt;p&gt;对于集合容器，有很多种。因为每一个容器的自身特点不同，其实原理在于每个容器的内部数据结构不同。&lt;/p&gt;
&lt;p&gt;集合容器在不断向上抽取过程中，出现了集合体系。 &lt;strong&gt;在使用一个体系的原则：参阅顶层内容。建立底层对象。&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&#34;使用集合框架的好处&#34;&gt;使用集合框架的好处&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;容量自增长；&lt;/li&gt;
&lt;li&gt;提供了高性能的数据结构和算法，使编码更轻松，提高了程序速度和质量；&lt;/li&gt;
&lt;li&gt;允许不同 API 之间的互操作，API之间可以来回传递集合；&lt;/li&gt;
&lt;li&gt;可以方便地扩展或改写集合，提高代码复用性和可操作性。&lt;/li&gt;
&lt;li&gt;通过使用JDK自带的集合类，可以降低代码维护和学习新API成本。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;常用的集合类有哪些&#34;&gt;常用的集合类有哪些？&lt;/h3&gt;
&lt;p&gt;Map接口和Collection接口是所有集合框架的父接口：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Collection接口的子接口包括：Set接口和List接口&lt;/li&gt;
&lt;li&gt;Map接口的实现类主要有：HashMap、TreeMap、Hashtable、ConcurrentHashMap以及Properties等&lt;/li&gt;
&lt;li&gt;Set接口的实现类主要有：HashSet、TreeSet、LinkedHashSet等&lt;/li&gt;
&lt;li&gt;List接口的实现类主要有：ArrayList、LinkedList、Stack以及Vector等&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;listsetmap三者的区别listsetmap-是否继承自-collection-接口listmapset-三个接口存取元素时各有什么特点&#34;&gt;List，Set，Map三者的区别？List、Set、Map 是否继承自 Collection 接口？List、Map、Set 三个接口存取元素时，各有什么特点？&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;https://cheneycqg.github.io/post/javacollectioncontainerinterviewquestions/2.jpg&#34;
	width=&#34;555&#34;
	height=&#34;420&#34;
	srcset=&#34;https://cheneycqg.github.io/post/javacollectioncontainerinterviewquestions/2_hu96c6ab7f91f5574cd29d0fc8a8e1a764_34263_480x0_resize_q75_box.jpg 480w, https://cheneycqg.github.io/post/javacollectioncontainerinterviewquestions/2_hu96c6ab7f91f5574cd29d0fc8a8e1a764_34263_1024x0_resize_q75_box.jpg 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;2&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;132&#34;
		data-flex-basis=&#34;317px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;Java 容器分为 Collection 和 Map 两大类，Collection集合的子接口有Set、List、Queue三种子接口。我们比较常用的是Set、List，Map接口不是collection的子接口。&lt;/p&gt;
&lt;p&gt;Collection集合主要有List和Set两大接口&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;List：一个有序（元素存入集合的顺序和取出的顺序一致）容器，元素可以重复，可以插入多个null元素，元素都有索引。常用的实现类有 ArrayList、LinkedList 和 Vector。&lt;/li&gt;
&lt;li&gt;Set：一个无序（存入和取出顺序有可能不一致）容器，不可以存储重复元素，只允许存入一个null元素，必须保证元素唯一性。Set 接口常用实现类是 HashSet、LinkedHashSet 以及 TreeSet。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Map是一个键值对集合，存储键、值和之间的映射。 Key无序，唯一；value 不要求有序，允许重复。Map没有继承于Collection接口，从Map集合中检索元素时，只要给出键对象，就会返回对应的值对象。&lt;/p&gt;
&lt;p&gt;Map 的常用实现类：HashMap、TreeMap、HashTable、LinkedHashMap、ConcurrentHashMap&lt;/p&gt;
&lt;h3 id=&#34;集合框架底层数据结构&#34;&gt;集合框架底层数据结构&lt;/h3&gt;
&lt;h4 id=&#34;collection&#34;&gt;Collection&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;List&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Arraylist： Object数组&lt;/li&gt;
&lt;li&gt;Vector： Object数组&lt;/li&gt;
&lt;li&gt;LinkedList： 双向循环链表&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Set&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;HashSet（无序，唯一）：基于 HashMap 实现的，底层采用 HashMap 来保存元素&lt;/li&gt;
&lt;li&gt;LinkedHashSet： LinkedHashSet 继承与 HashSet，并且其内部是通过 LinkedHashMap 来实现的。有点类似于我们之前说的LinkedHashMap 其内部是基于 Hashmap 实现一样，不过还是有一点点区别的。&lt;/li&gt;
&lt;li&gt;TreeSet（有序，唯一）： 红黑树(自平衡的排序二叉树。)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;map&#34;&gt;Map&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;HashMap： JDK1.8之前HashMap由数组+链表组成的，数组是HashMap的主体，链表则是主要为了解决哈希冲突而存在的（&amp;ldquo;拉链法&amp;quot;解决冲突）.JDK1.8以后在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为8）时，将链表转化为红黑树，以减少搜索时间&lt;/li&gt;
&lt;li&gt;LinkedHashMap：LinkedHashMap 继承自 HashMap，所以它的底层仍然是基于拉链式散列结构即由数组和链表或红黑树组成。另外，LinkedHashMap 在上面结构的基础上，增加了一条双向链表，使得上面的结构可以保持键值对的插入顺序。同时通过对链表进行相应的操作，实现了访问顺序相关逻辑。&lt;/li&gt;
&lt;li&gt;HashTable： 数组+链表组成的，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的&lt;/li&gt;
&lt;li&gt;TreeMap： 红黑树（自平衡的排序二叉树）&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;哪些集合类是线程安全的&#34;&gt;哪些集合类是线程安全的？&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;vector：就比arraylist多了个同步化机制（线程安全），因为效率较低，现在已经不太建议使用。在web应用中，特别是前台页面，往往效率（页面响应速度）是优先考虑的。&lt;/li&gt;
&lt;li&gt;statck：堆栈类，先进后出。&lt;/li&gt;
&lt;li&gt;hashtable：就比hashmap多了个线程安全。&lt;/li&gt;
&lt;li&gt;enumeration：枚举，相当于迭代器。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;java集合的快速失败机制-fail-fast&#34;&gt;Java集合的快速失败机制 &amp;ldquo;fail-fast&amp;rdquo;？&lt;/h3&gt;
&lt;p&gt;是java集合的一种错误检测机制，当多个线程对集合进行结构上的改变的操作时，有可能会产生 fail-fast 机制。&lt;/p&gt;
&lt;p&gt;例如：假设存在两个线程（线程1、线程2），线程1通过Iterator在遍历集合A中的元素，在某个时候线程2修改了集合A的结构（是结构上面的修改，而不是简单的修改集合元素的内容），那么这个时候程序就会抛出 ConcurrentModificationException 异常，从而产生fail-fast机制。&lt;/p&gt;
&lt;p&gt;原因：迭代器在遍历时直接访问集合中的内容，并且在遍历过程中使用一个 modCount 变量。集合在被遍历期间如果内容发生变化，就会改变modCount的值。每当迭代器使用hashNext()/next()遍历下一个元素之前，都会检测modCount变量是否为expectedmodCount值，是的话就返回遍历；否则抛出异常，终止遍历。&lt;/p&gt;
&lt;p&gt;解决办法：&lt;/p&gt;
&lt;p&gt;在遍历过程中，所有涉及到改变modCount值得地方全部加上synchronized。&lt;/p&gt;
&lt;p&gt;使用CopyOnWriteArrayList来替换ArrayList&lt;/p&gt;
&lt;h3 id=&#34;怎么确保一个集合不能被修改&#34;&gt;怎么确保一个集合不能被修改？&lt;/h3&gt;
&lt;p&gt;可以使用 Collections. unmodifiableCollection(Collection c) 方法来创建一个只读集合，这样改变集合的任何操作都会抛出 Java. lang. UnsupportedOperationException 异常。&lt;/p&gt;
&lt;p&gt;示例代码如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;List&amp;lt;String&amp;gt; list = new ArrayList&amp;lt;&amp;gt;();

list.add(&amp;quot;x&amp;quot;);

Collection&amp;lt;String&amp;gt; clist = Collections. unmodifiableCollection(list);

clist.add(&amp;quot;y&amp;quot;); // 运行时此行报错

System.out.println(list.size());
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;collection接口&#34;&gt;Collection接口&lt;/h2&gt;
&lt;h3 id=&#34;list接口&#34;&gt;List接口&lt;/h3&gt;
&lt;h4 id=&#34;迭代器-iterator-是什么&#34;&gt;迭代器 Iterator 是什么？&lt;/h4&gt;
&lt;p&gt;Iterator 接口提供遍历任何 Collection 的接口。我们可以从一个 Collection 中使用迭代器方法来获取迭代器实例。迭代器取代了 Java 集合框架中的 Enumeration，迭代器允许调用者在迭代过程中移除元素。&lt;/p&gt;
&lt;h4 id=&#34;iterator-怎么使用有什么特点&#34;&gt;Iterator 怎么使用？有什么特点？&lt;/h4&gt;
&lt;p&gt;Iterator 使用代码如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;List&amp;lt;String&amp;gt; list = new ArrayList&amp;lt;&amp;gt;();

Iterator&amp;lt;String&amp;gt; it = list.iterator();

while(it.hasNext()){

String obj = it.next();

System.out.println(obj);

}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Iterator 的特点是只能单向遍历，但是更加安全，因为它可以确保，在当前遍历的集合元素被更改的时候，就会抛出 ConcurrentModificationException 异常。&lt;/p&gt;
&lt;h4 id=&#34;如何边遍历边移除-collection-中的元素&#34;&gt;如何边遍历边移除 Collection 中的元素？&lt;/h4&gt;
&lt;p&gt;边遍历边修改 Collection 的唯一正确方式是使用 Iterator.remove() 方法，如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Iterator&amp;lt;Integer&amp;gt; it = list.iterator();
while(it.hasNext()){

// do something

it.remove();}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;一种最常见的 &lt;strong&gt;错误&lt;/strong&gt; 代码如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;for(Integer i : list){

list.remove(i)}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;运行以上错误代码会报 &lt;strong&gt;ConcurrentModificationException&lt;/strong&gt;  &lt;strong&gt;异常&lt;/strong&gt; 。这是因为当使用 foreach(for(Integer i : list)) 语句时，会自动生成一个iterator 来遍历该 list，但同时该 list 正在被 Iterator.remove() 修改。Java 一般不允许一个线程在遍历 Collection 时另一个线程修改它。&lt;/p&gt;
&lt;h4 id=&#34;iterator-和-listiterator-有什么区别&#34;&gt;Iterator 和 ListIterator 有什么区别？&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;Iterator 可以遍历 Set 和 List 集合，而 ListIterator 只能遍历 List。&lt;/li&gt;
&lt;li&gt;Iterator 只能单向遍历，而 ListIterator 可以双向遍历（向前/后遍历）。&lt;/li&gt;
&lt;li&gt;ListIterator 实现 Iterator 接口，然后添加了一些额外的功能，比如添加一个元素、替换一个元素、获取前面或后面元素的索引位置。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;遍历一个-list-有哪些不同的方式每种方法的实现原理是什么java-中-list-遍历的最佳实践是什么&#34;&gt;遍历一个 List 有哪些不同的方式？每种方法的实现原理是什么？Java 中 List 遍历的最佳实践是什么？&lt;/h4&gt;
&lt;p&gt;遍历方式有以下几种：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;for 循环遍历，基于计数器。在集合外部维护一个计数器，然后依次读取每一个位置的元素，当读取到最后一个元素后停止。&lt;/li&gt;
&lt;li&gt;迭代器遍历，Iterator。Iterator 是面向对象的一个设计模式，目的是屏蔽不同数据集合的特点，统一遍历集合的接口。Java 在 Collections 中支持了 Iterator 模式。&lt;/li&gt;
&lt;li&gt;foreach 循环遍历。foreach 内部也是采用了 Iterator 的方式实现，使用时不需要显式声明 Iterator 或计数器。优点是代码简洁，不易出错；缺点是只能做简单的遍历，不能在遍历过程中操作数据集合，例如删除、替换。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;最佳实践：Java Collections 框架中提供了一个 RandomAccess 接口，用来标记 List 实现是否支持 Random Access。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果一个数据集合实现了该接口，就意味着它支持 Random Access，按位置读取元素的平均时间复杂度为 O(1)，如ArrayList。&lt;/li&gt;
&lt;li&gt;如果没有实现该接口，表示不支持 Random Access，如LinkedList。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;推荐的做法就是，支持 Random Access 的列表可用 for 循环遍历，否则建议用 Iterator 或 foreach 遍历。&lt;/p&gt;
&lt;h4 id=&#34;说一下-arraylist-的优缺点&#34;&gt;说一下 ArrayList 的优缺点&lt;/h4&gt;
&lt;p&gt;ArrayList的优点如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ArrayList 底层以数组实现，是一种随机访问模式。ArrayList 实现了 RandomAccess 接口，因此查找的时候非常快。&lt;/li&gt;
&lt;li&gt;ArrayList 在顺序添加一个元素的时候非常方便。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;ArrayList 的缺点如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;删除元素的时候，需要做一次元素复制操作。如果要复制的元素很多，那么就会比较耗费性能。&lt;/li&gt;
&lt;li&gt;插入元素的时候，也需要做一次元素复制操作，缺点同上。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;ArrayList 比较适合顺序添加、随机访问的场景。&lt;/p&gt;
&lt;h4 id=&#34;如何实现数组和-list-之间的转换&#34;&gt;如何实现数组和 List 之间的转换？&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;数组转 List：使用 Arrays. asList(array) 进行转换。&lt;/li&gt;
&lt;li&gt;List 转数组：使用 List 自带的 toArray() 方法。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;代码示例：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// list to array

List&amp;lt;String&amp;gt; list = new ArrayList&amp;lt;String&amp;gt;();

list.add(&amp;quot;123&amp;quot;);

list.add(&amp;quot;456&amp;quot;);

list.toArray();

// array to list

String[] array = new String[]{&amp;quot;123&amp;quot;,&amp;quot;456&amp;quot;};

Arrays.asList(array);
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;arraylist-和-linkedlist-的区别是什么&#34;&gt;ArrayList 和 LinkedList 的区别是什么？&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;数据结构实现：ArrayList 是动态数组的数据结构实现，而 LinkedList 是双向链表的数据结构实现。&lt;/li&gt;
&lt;li&gt;随机访问效率：ArrayList 比 LinkedList 在随机访问的时候效率要高，因为 LinkedList 是线性的数据存储方式，所以需要移动指针从前往后依次查找。&lt;/li&gt;
&lt;li&gt;增加和删除效率：在非首尾的增加和删除操作，LinkedList 要比 ArrayList 效率要高，因为 ArrayList 增删操作要影响数组内的其他数据的下标。&lt;/li&gt;
&lt;li&gt;内存空间占用：LinkedList 比 ArrayList 更占内存，因为 LinkedList 的节点除了存储数据，还存储了两个引用，一个指向前一个元素，一个指向后一个元素。&lt;/li&gt;
&lt;li&gt;线程安全：ArrayList 和 LinkedList 都是不同步的，也就是不保证线程安全；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;综合来说，在需要频繁读取集合中的元素时，更推荐使用 ArrayList，而在插入和删除操作较多时，更推荐使用 LinkedList。&lt;/p&gt;
&lt;p&gt;补充：数据结构基础之双向链表&lt;/p&gt;
&lt;p&gt;双向链表也叫双链表，是链表的一种，它的每个数据结点中都有两个指针，分别指向直接后继和直接前驱。所以，从双向链表中的任意一个结点开始，都可以很方便地访问它的前驱结点和后继结点。&lt;/p&gt;
&lt;h4 id=&#34;arraylist-和-vector-的区别是什么&#34;&gt;ArrayList 和 Vector 的区别是什么？&lt;/h4&gt;
&lt;p&gt;这两个类都实现了 List 接口（List 接口继承了 Collection 接口），他们都是有序集合&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;线程安全：Vector 使用了 Synchronized 来实现线程同步，是线程安全的，而 ArrayList 是非线程安全的。&lt;/li&gt;
&lt;li&gt;性能：ArrayList 在性能方面要优于 Vector。&lt;/li&gt;
&lt;li&gt;扩容：ArrayList 和 Vector 都会根据实际的需要动态的调整容量，只不过在 Vector 扩容每次会增加 1 倍，而 ArrayList 只会增加 50%。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Vector类的所有方法都是同步的。可以由两个线程安全地访问一个Vector对象、但是一个线程访问Vector的话代码要在同步操作上耗费大量的时间。&lt;/p&gt;
&lt;p&gt;Arraylist不是同步的，所以在不需要保证线程安全时时建议使用Arraylist。&lt;/p&gt;
&lt;h4 id=&#34;插入数据时arraylistlinkedlistvector谁速度较快阐述-arraylistvectorlinkedlist-的存储性能和特性&#34;&gt;插入数据时，ArrayList、LinkedList、Vector谁速度较快？阐述 ArrayList、Vector、LinkedList 的存储性能和特性？&lt;/h4&gt;
&lt;p&gt;ArrayList、LinkedList、Vector 底层的实现都是使用数组方式存储数据。数组元素数大于实际存储的数据以便增加和插入元素，它们都允许直接按序号索引元素，但是插入元素要涉及数组元素移动等内存操作，所以索引数据快而插入数据慢。&lt;/p&gt;
&lt;p&gt;Vector 中的方法由于加了 synchronized 修饰，因此 &lt;strong&gt;Vector&lt;/strong&gt;** 是线程安全容器，但性能上较 &lt;strong&gt;&lt;strong&gt;ArrayList&lt;/strong&gt;&lt;/strong&gt; 差**。&lt;/p&gt;
&lt;p&gt;LinkedList 使用双向链表实现存储，按序号索引数据需要进行前向或后向遍历，但插入数据时只需要记录当前项的前后项即可，所以 &lt;strong&gt;LinkedList&lt;/strong&gt;** 插入速度较快**。&lt;/p&gt;
&lt;h4 id=&#34;多线程场景下如何使用-arraylist&#34;&gt;多线程场景下如何使用 ArrayList？&lt;/h4&gt;
&lt;p&gt;ArrayList 不是线程安全的，如果遇到多线程场景，可以通过 Collections 的 synchronizedList 方法将其转换成线程安全的容器后再使用。例如像下面这样：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;List&amp;lt;String&amp;gt; synchronizedList = Collections.synchronizedList(list);

synchronizedList.add(&amp;quot;aaa&amp;quot;);

synchronizedList.add(&amp;quot;bbb&amp;quot;);

for(int i =0; i &amp;lt; synchronizedList.size(); i++){

System.out.println(synchronizedList.get(i));}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;为什么-arraylist-的-elementdata-加上-transient-修饰&#34;&gt;为什么 ArrayList 的 elementData 加上 transient 修饰？&lt;/h4&gt;
&lt;p&gt;ArrayList 中的数组定义如下：&lt;/p&gt;
&lt;p&gt;privatetransient Object[] elementData;&lt;/p&gt;
&lt;p&gt;再看一下 ArrayList 的定义：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;publicclassArrayList&amp;lt;E&amp;gt;extendsAbstractList&amp;lt;E&amp;gt;

implementsList&amp;lt;E&amp;gt;, RandomAccess, Cloneable, java.io.Serializable
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可以看到 ArrayList 实现了 Serializable 接口，这意味着 ArrayList 支持序列化。transient 的作用是说不希望 elementData 数组被序列化，重写了 writeObject 实现：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;privatevoidwriteObject(java.io.ObjectOutputStream s)throws java.io.IOException{

// Write out element count, and any hidden stuff

int expectedModCount = modCount;

s.defaultWriteObject();

// Write out array length

s.writeInt(elementData.length);

// Write out all elements in the proper order.

for(int i=0; i&amp;lt;size; i++)

s.writeObject(elementData[i]);

if(modCount != expectedModCount){

thrownewConcurrentModificationException();}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;每次序列化时，先调用 defaultWriteObject() 方法序列化 ArrayList 中的非 transient 元素，然后遍历 elementData，只序列化已存入的元素，这样既加快了序列化的速度，又减小了序列化之后的文件大小。&lt;/p&gt;
&lt;h4 id=&#34;list-和-set-的区别&#34;&gt;List 和 Set 的区别&lt;/h4&gt;
&lt;p&gt;List , Set 都是继承自Collection 接口&lt;/p&gt;
&lt;p&gt;List 特点：一个有序（元素存入集合的顺序和取出的顺序一致）容器，元素可以重复，可以插入多个null元素，元素都有索引。常用的实现类有 ArrayList、LinkedList 和 Vector。&lt;/p&gt;
&lt;p&gt;Set 特点：一个无序（存入和取出顺序有可能不一致）容器，不可以存储重复元素，只允许存入一个null元素，必须保证元素唯一性。Set 接口常用实现类是 HashSet、LinkedHashSet 以及 TreeSet。&lt;/p&gt;
&lt;p&gt;另外 List 支持for循环，也就是通过下标来遍历，也可以用迭代器，但是set只能用迭代，因为他无序，无法用下标来取得想要的值。&lt;/p&gt;
&lt;p&gt;Set和List对比&lt;/p&gt;
&lt;p&gt;Set：检索元素效率低下，删除和插入效率高，插入和删除不会引起元素位置改变。
List：和数组类似，List可以动态增长，查找元素效率高，插入删除元素效率低，因为会引起其他元素位置改变&lt;/p&gt;
&lt;h3 id=&#34;set接口&#34;&gt;Set接口&lt;/h3&gt;
&lt;h4 id=&#34;说一下-hashset-的实现原理&#34;&gt;说一下 HashSet 的实现原理？&lt;/h4&gt;
&lt;p&gt;HashSet 是基于 HashMap 实现的，HashSet的值存放于HashMap的key上，HashMap的value统一为PRESENT，因此 HashSet 的实现比较简单，相关 HashSet 的操作，基本上都是直接调用底层 HashMap 的相关方法来完成，HashSet 不允许重复的值。&lt;/p&gt;
&lt;h4 id=&#34;hashset如何检查重复hashset是如何保证数据不可重复的&#34;&gt;HashSet如何检查重复？HashSet是如何保证数据不可重复的？&lt;/h4&gt;
&lt;p&gt;向HashSet 中add ()元素时，判断元素是否存在的依据，不仅要比较hash值，同时还要结合equles 方法比较。
HashSet 中的add ()方法会使用HashMap 的put()方法。&lt;/p&gt;
&lt;p&gt;HashMap 的 key 是唯一的，由源码可以看出 HashSet 添加进去的值就是作为HashMap 的key，并且在HashMap中如果K/V相同时，会用新的V覆盖掉旧的V，然后返回旧的V。所以不会重复（ HashMap 比较key是否相等是先比较hashcode 再比较equals ）。&lt;/p&gt;
&lt;p&gt;以下是HashSet 部分源码：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;privatestaticfinal Object PRESENT =newObject();
privatetransient HashMap&amp;lt;E,Object&amp;gt; map;

publicHashSet(){

map =newHashMap&amp;lt;&amp;gt;();}

publicbooleanadd(E e){

// 调用HashMap的put方法,PRESENT是一个至始至终都相同的虚值

return map.put(e, PRESENT)==null;}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;hashCode&lt;/strong&gt;** （）与 &lt;strong&gt;&lt;strong&gt;equals&lt;/strong&gt;&lt;/strong&gt; （）的相关规定**：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;如果两个对象相等，则hashcode一定也是相同的&lt;/li&gt;
&lt;li&gt;两个对象相等,对两个equals方法返回true&lt;/li&gt;
&lt;li&gt;两个对象有相同的hashcode值，它们也不一定是相等的&lt;/li&gt;
&lt;li&gt;综上，equals方法被覆盖过，则hashCode方法也必须被覆盖&lt;/li&gt;
&lt;li&gt;hashCode()的默认行为是对堆上的对象产生独特值。如果没有重写hashCode()，则该class的两个对象无论如何都不会相等（即使这两个对象指向相同的数据）。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;==&lt;/strong&gt;** 与 &lt;strong&gt;&lt;strong&gt;equals&lt;/strong&gt;&lt;/strong&gt; 的区别**&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;==是判断两个变量或实例是不是指向同一个内存空间 equals是判断两个变量或实例所指向的内存空间的值是不是相同&lt;/li&gt;
&lt;li&gt;==是指对内存地址进行比较 equals()是对字符串的内容进行比较&lt;/li&gt;
&lt;li&gt;==指引用是否相同 equals()指的是值是否相同&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;hashset与hashmap的区别&#34;&gt;HashSet与HashMap的区别&lt;/h4&gt;
&lt;p&gt;&lt;img src=&#34;https://cheneycqg.github.io/post/javacollectioncontainerinterviewquestions/3.jpg&#34;
	width=&#34;703&#34;
	height=&#34;355&#34;
	srcset=&#34;https://cheneycqg.github.io/post/javacollectioncontainerinterviewquestions/3_hu54ca66d67e7727ee4e1fe498577c2aec_36823_480x0_resize_q75_box.jpg 480w, https://cheneycqg.github.io/post/javacollectioncontainerinterviewquestions/3_hu54ca66d67e7727ee4e1fe498577c2aec_36823_1024x0_resize_q75_box.jpg 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;3&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;198&#34;
		data-flex-basis=&#34;475px&#34;
	
&gt;&lt;/p&gt;
&lt;h3 id=&#34;queue&#34;&gt;Queue&lt;/h3&gt;
&lt;h4 id=&#34;blockingqueue是什么&#34;&gt;BlockingQueue是什么？&lt;/h4&gt;
&lt;p&gt;Java.util.concurrent.BlockingQueue是一个队列，在进行检索或移除一个元素的时候，它会等待队列变为非空；当在添加一个元素时，它会等待队列中的可用空间。&lt;/p&gt;
&lt;p&gt;BlockingQueue接口是Java集合框架的一部分，主要用于实现生产者-消费者模式。我们不需要担心等待生产者有可用的空间，或消费者有可用的对象，因为它都在BlockingQueue的实现类中被处理了。&lt;/p&gt;
&lt;p&gt;Java提供了集中BlockingQueue的实现，比如ArrayBlockingQueue、LinkedBlockingQueue、PriorityBlockingQueue,、SynchronousQueue等。&lt;/p&gt;
&lt;h4 id=&#34;在-queue-中-poll和-remove有什么区别&#34;&gt;在 Queue 中 poll()和 remove()有什么区别？&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;相同点：都是返回第一个元素，并在队列中删除返回的对象。&lt;/li&gt;
&lt;li&gt;不同点：如果没有元素 poll()会返回 null，而 remove()会直接抛出 NoSuchElementException 异常。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;代码示例：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Queue&amp;lt;String&amp;gt; queue = new LinkedList&amp;lt;String&amp;gt;();

queue.offer(&amp;quot;string&amp;quot;); // add

System.out.println(queue.poll());

System.out.println(queue.remove());

System.out.println(queue.size());
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;map接口&#34;&gt;Map接口&lt;/h2&gt;
&lt;h3 id=&#34;说一下-hashmap-的实现原理&#34;&gt;说一下 HashMap 的实现原理？&lt;/h3&gt;
&lt;p&gt;HashMap概述： HashMap是基于哈希表的Map接口的非同步实现。此实现提供所有可选的映射操作，并允许使用null值和null键。此类不保证映射的顺序，特别是它不保证该顺序恒久不变。&lt;/p&gt;
&lt;p&gt;HashMap的数据结构： 在Java编程语言中，最基本的结构就是两种，一个是数组，另外一个是模拟指针（引用），所有的数据结构都可以用这两个基本结构来构造的，HashMap也不例外。HashMap实际上是一个&amp;quot;链表散列&amp;quot;的数据结构，即数组和链表的结合体。&lt;/p&gt;
&lt;p&gt;HashMap 基于 Hash 算法实现的&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;当我们往Hashmap中put元素时，利用key的hashCode重新hash计算出当前对象的元素在数组中的下标&lt;/li&gt;
&lt;li&gt;存储时，如果出现hash值相同的key，此时有两种情况。(1)如果key相同，则覆盖原始值；(2)如果key不同（出现冲突），则将当前的key-value放入链表中&lt;/li&gt;
&lt;li&gt;获取时，直接找到hash值对应的下标，在进一步判断key是否相同，从而找到对应值。&lt;/li&gt;
&lt;li&gt;理解了以上过程就不难明白HashMap是如何解决hash冲突的问题，核心就是使用了数组的存储方式，然后将冲突的key的对象放入链表中，一旦发现冲突就在链表中做进一步的对比。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;需要注意Jdk 1.8中对HashMap的实现做了优化，当链表中的节点数据超过八个之后，该链表会转为红黑树来提高查询效率，从原来的O(n)到O(logn)&lt;/p&gt;
&lt;h3 id=&#34;hashmap在jdk17和jdk18中有哪些不同hashmap的底层实现&#34;&gt;HashMap在JDK1.7和JDK1.8中有哪些不同？HashMap的底层实现&lt;/h3&gt;
&lt;p&gt;在Java中，保存数据有两种比较简单的数据结构：数组和链表。 &lt;strong&gt;数组的特点是：寻址容易，插入和删除困难；链表的特点是：寻址困难，但插入和删除容易；所以我们将数组和链表结合在一起，发挥两者各自的优势，使用一种叫做拉链法&lt;/strong&gt; 的方式可以解决哈希冲突。&lt;/p&gt;
&lt;h4 id=&#34;jdk18之前&#34;&gt;JDK1.8之前&lt;/h4&gt;
&lt;p&gt;JDK1.8之前采用的是拉链法。 &lt;strong&gt;拉链法&lt;/strong&gt; ：将链表和数组相结合。也就是说创建一个链表数组，数组中每一格就是一个链表。若遇到哈希冲突，则将冲突的值加到链表中即可。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cheneycqg.github.io/post/javacollectioncontainerinterviewquestions/4.jpg&#34;
	width=&#34;444&#34;
	height=&#34;481&#34;
	srcset=&#34;https://cheneycqg.github.io/post/javacollectioncontainerinterviewquestions/4_hu164f62cb8821d08e7dff5281f3360d92_16193_480x0_resize_q75_box.jpg 480w, https://cheneycqg.github.io/post/javacollectioncontainerinterviewquestions/4_hu164f62cb8821d08e7dff5281f3360d92_16193_1024x0_resize_q75_box.jpg 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;4&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;92&#34;
		data-flex-basis=&#34;221px&#34;
	
&gt;&lt;/p&gt;
&lt;h4 id=&#34;jdk18之后&#34;&gt;JDK1.8之后&lt;/h4&gt;
&lt;p&gt;相比于之前的版本，jdk1.8在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为8）时，将链表转化为红黑树，以减少搜索时间。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cheneycqg.github.io/post/javacollectioncontainerinterviewquestions/5.jpg&#34;
	width=&#34;501&#34;
	height=&#34;282&#34;
	srcset=&#34;https://cheneycqg.github.io/post/javacollectioncontainerinterviewquestions/5_hufe9994d76a413209b9e3ac7de420ebec_41545_480x0_resize_q75_box.jpg 480w, https://cheneycqg.github.io/post/javacollectioncontainerinterviewquestions/5_hufe9994d76a413209b9e3ac7de420ebec_41545_1024x0_resize_q75_box.jpg 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;5&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;177&#34;
		data-flex-basis=&#34;426px&#34;
	
&gt;&lt;/p&gt;
&lt;h4 id=&#34;jdk17-vs-jdk18-比较&#34;&gt;JDK1.7 VS JDK1.8 比较&lt;/h4&gt;
&lt;p&gt;JDK1.8主要解决或优化了一下问题：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;resize 扩容优化&lt;/li&gt;
&lt;li&gt;引入了红黑树，目的是避免单条链表过长而影响查询效率，红黑树算法请参考&lt;/li&gt;
&lt;li&gt;解决了多线程死循环问题，但仍是非线程安全的，多线程时可能会造成数据丢失问题。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&#34;https://cheneycqg.github.io/post/javacollectioncontainerinterviewquestions/6.jpg&#34;
	width=&#34;710&#34;
	height=&#34;420&#34;
	srcset=&#34;https://cheneycqg.github.io/post/javacollectioncontainerinterviewquestions/6_hu499c6f4360b731dbe468e36d8840f769_55495_480x0_resize_q75_box.jpg 480w, https://cheneycqg.github.io/post/javacollectioncontainerinterviewquestions/6_hu499c6f4360b731dbe468e36d8840f769_55495_1024x0_resize_q75_box.jpg 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;6&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;169&#34;
		data-flex-basis=&#34;405px&#34;
	
&gt;&lt;/p&gt;
&lt;h3 id=&#34;hashmap的put方法的具体流程&#34;&gt;HashMap的put方法的具体流程？&lt;/h3&gt;
&lt;p&gt;当我们put的时候，首先计算 key的hash值，这里调用了 hash方法，hash方法实际是让key.hashCode()与key.hashCode()&amp;gt;&amp;gt;&amp;gt;16进行异或操作，高16bit补0，一个数和0异或不变，所以 hash 函数大概的作用就是： &lt;strong&gt;高&lt;/strong&gt;** 16bit &lt;strong&gt;&lt;strong&gt;不变，低&lt;/strong&gt;&lt;/strong&gt; 16bit &lt;strong&gt;&lt;strong&gt;和高&lt;/strong&gt;&lt;/strong&gt; 16bit **&lt;strong&gt;做了一个异或，目的是减少碰撞&lt;/strong&gt; 。&lt;/p&gt;
&lt;p&gt;按照函数注释，因为bucket数组大小是2的幂，计算下标index = (table.length - 1) &amp;amp; hash，如果不做 hash 处理，相当于散列生效的只有几个低 bit 位，为了减少散列的碰撞，设计者综合考虑了速度、作用、质量之后，使用高16bit和低16bit异或来简单处理减少碰撞，而且JDK8中用了复杂度 O（logn）的树结构来提升碰撞下的性能。&lt;/p&gt;
&lt;p&gt;putVal方法执行流程图&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cheneycqg.github.io/post/javacollectioncontainerinterviewquestions/7.jpg&#34;
	width=&#34;506&#34;
	height=&#34;343&#34;
	srcset=&#34;https://cheneycqg.github.io/post/javacollectioncontainerinterviewquestions/7_hu9771643d9fcb80f38324edddaa42aec1_49259_480x0_resize_q75_box.jpg 480w, https://cheneycqg.github.io/post/javacollectioncontainerinterviewquestions/7_hu9771643d9fcb80f38324edddaa42aec1_49259_1024x0_resize_q75_box.jpg 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;7&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;147&#34;
		data-flex-basis=&#34;354px&#34;
	
&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public V put(K key, V value){

	returnputVal(hash(key), key, value,false,true);}

	staticfinalinthash(Object key){

	int h;

	return(key == null)?0:(h = key.hashCode())^(h &amp;gt;&amp;gt;&amp;gt;16);
}

//实现Map.put和相关方法
final V putVal(int hash, K key, V value,boolean onlyIfAbsent,boolean evict){

	Node&amp;lt;K,V&amp;gt;[] tab; Node&amp;lt;K,V&amp;gt; p;int n, i;

	// 步骤①：tab为空则创建

	// table未初始化或者长度为0，进行扩容

	if((tab = table)== null ||(n = tab.length)==0)

		n =(tab =resize()).length;

	// 步骤②：计算index，并对null做处理

	// (n - 1) &amp;amp; hash 确定元素存放在哪个桶中，桶为空，新生成结点放入桶中(此时，这个结点是放在数组中)

	if((p = tab[i =(n -1)&amp;amp; hash])== null)

		tab[i]=newNode(hash, key, value, null);

	// 桶中已经存在元素

	else{

		Node&amp;lt;K,V&amp;gt; e; K k;

		// 步骤③：节点key存在，直接覆盖value

		// 比较桶中第一个元素(数组中的结点)的hash值相等，key相等

		if(p.hash == hash &amp;amp;&amp;amp;((k = p.key)== key ||(key != null &amp;amp;&amp;amp; key.equals(k))))

			// 将第一个元素赋值给e，用e来记录

			e = p;

			// 步骤④：判断该链为红黑树

			// hash值不相等，即key不相等；为红黑树结点

			// 如果当前元素类型为TreeNode，表示为红黑树，putTreeVal返回待存放的node, e可能为null

		elseif(p instanceofTreeNode)

			// 放入树中

			e =((TreeNode&amp;lt;K,V&amp;gt;)p).putTreeVal(this, tab, hash, key, value);

			// 步骤⑤：该链为链表

			// 为链表结点

		else{

			// 在链表最末插入结点

			for(int binCount =0;;++binCount){

				// 到达链表的尾部

				//判断该链表尾部指针是不是空的

				if((e = p.next)== null){

					// 在尾部插入新结点

					p.next =newNode(hash, key, value, null);

					//判断链表的长度是否达到转化红黑树的临界值，临界值为8

					if(binCount &amp;gt;= TREEIFY_THRESHOLD -1)// -1 for 1st

						//链表结构转树形结构

						treeifyBin(tab, hash);

						// 跳出循环

						break;

					}

				// 判断链表中结点的key值与插入的元素的key值是否相等

				if(e.hash == hash &amp;amp;&amp;amp;((k = e.key)== key ||(key != null &amp;amp;&amp;amp; key.equals(k))))

					// 相等，跳出循环

					break;

					// 用于遍历桶中的链表，与前面的e = p.next组合，可以遍历链表

					p = e;

				}

			}

			//判断当前的key已经存在的情况下，再来一个相同的hash值、key值时，返回新来的value这个值

			if(e != null){

				// 记录e的value

				V oldValue = e.value;

				// onlyIfAbsent为false或者旧值为null

				if(!onlyIfAbsent || oldValue == null)

				//用新值替换旧值

				e.value = value;

				// 访问后回调

				afterNodeAccess(e);

				// 返回旧值

				return oldValue;

			}

		}

		// 结构性修改

		++modCount;

		// 步骤⑥：超过最大容量就扩容

		// 实际大小大于阈值则扩容

		if(++size &amp;gt; threshold)

				resize();

		// 插入后回调

		afterNodeInsertion(evict);

		return null;}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;①.判断键值对数组table[i]是否为空或为null，否则执行resize()进行扩容；&lt;/p&gt;
&lt;p&gt;②.根据键值key计算hash值得到插入的数组索引i，如果table[i]==null，直接新建节点添加，转向⑥，如果table[i]不为空，转向③；&lt;/p&gt;
&lt;p&gt;③.判断table[i]的首个元素是否和key一样，如果相同直接覆盖value，否则转向④，这里的相同指的是hashCode以及equals；&lt;/p&gt;
&lt;p&gt;④.判断table[i] 是否为treeNode，即table[i] 是否是红黑树，如果是红黑树，则直接在树中插入键值对，否则转向⑤；&lt;/p&gt;
&lt;p&gt;⑤.遍历table[i]，判断链表长度是否大于8，大于8的话把链表转换为红黑树，在红黑树中执行插入操作，否则进行链表的插入操作；遍历过程中若发现key已经存在直接覆盖value即可；&lt;/p&gt;
&lt;p&gt;⑥.插入成功后，判断实际存在的键值对数量size是否超多了最大容量threshold，如果超过，进行扩容。&lt;/p&gt;
&lt;h3 id=&#34;hashmap的扩容操作是怎么实现的&#34;&gt;HashMap的扩容操作是怎么实现的？&lt;/h3&gt;
&lt;p&gt;①.在jdk1.8中，resize方法是在hashmap中的键值对大于阀值时或者初始化时，就调用resize方法进行扩容；&lt;/p&gt;
&lt;p&gt;②.每次扩展的时候，都是扩展2倍；&lt;/p&gt;
&lt;p&gt;③.扩展后Node对象的位置要么在原位置，要么移动到原偏移量两倍的位置。&lt;/p&gt;
&lt;p&gt;在putVal()中，我们看到在这个函数里面使用到了2次resize()方法，resize()方法表示的在进行第一次初始化时会对其进行扩容，或者当该数组的实际大小大于其临界值值(第一次为12),这个时候在扩容的同时也会伴随的桶上面的元素进行重新分发，这也是JDK1.8版本的一个优化的地方，在1.7中，扩容之后需要重新去计算其Hash值，根据Hash值对其进行分发，但在1.8版本中，则是根据在同一个桶的位置中进行判断(e.hash &amp;amp; oldCap)是否为0，重新进行hash分配后，该元素的位置要么停留在原始位置，要么移动到原始位置+增加的数组大小这个位置上&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;final Node&amp;lt;K,V&amp;gt;[] resize() {
Node&amp;lt;K,V&amp;gt;[] oldTab = table;//oldTab指向hash桶数组
int oldCap = (oldTab == null) ? 0 : oldTab.length;
int oldThr = threshold;
int newCap, newThr = 0;
if (oldCap &amp;gt; 0) {//如果oldCap不为空的话，就是hash桶数组不为空
    if (oldCap &amp;gt;= MAXIMUM_CAPACITY) {//如果大于最大容量了，就赋值为整数最大的阀值
        threshold = Integer.MAX_VALUE;
        return oldTab;//返回
    }//如果当前hash桶数组的长度在扩容后仍然小于最大容量 并且oldCap大于默认值16
    else if ((newCap = oldCap &amp;lt;&amp;lt; 1) &amp;lt; MAXIMUM_CAPACITY &amp;amp;&amp;amp;
             oldCap &amp;gt;= DEFAULT_INITIAL_CAPACITY)
        newThr = oldThr &amp;lt;&amp;lt; 1; // double threshold 双倍扩容阀值threshold
}
// 旧的容量为0，但threshold大于零，代表有参构造有cap传入，threshold已经被初始化成最小2的n次幂
// 直接将该值赋给新的容量
else if (oldThr &amp;gt; 0) // initial capacity was placed in threshold
    newCap = oldThr;
// 无参构造创建的map，给出默认容量和threshold 16, 16*0.75
else {               // zero initial threshold signifies using defaults
    newCap = DEFAULT_INITIAL_CAPACITY;
    newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);
}
// 新的threshold = 新的cap * 0.75
if (newThr == 0) {
    float ft = (float)newCap * loadFactor;
    newThr = (newCap &amp;lt; MAXIMUM_CAPACITY &amp;amp;&amp;amp; ft &amp;lt; (float)MAXIMUM_CAPACITY ?
              (int)ft : Integer.MAX_VALUE);
}
threshold = newThr;
// 计算出新的数组长度后赋给当前成员变量table
@SuppressWarnings({&amp;quot;rawtypes&amp;quot;,&amp;quot;unchecked&amp;quot;})
    Node&amp;lt;K,V&amp;gt;[] newTab = (Node&amp;lt;K,V&amp;gt;[])new Node[newCap];//新建hash桶数组
table = newTab;//将新数组的值复制给旧的hash桶数组
// 如果原先的数组没有初始化，那么resize的初始化工作到此结束，否则进入扩容元素重排逻辑，使其均匀的分散
if (oldTab != null) {
    // 遍历新数组的所有桶下标
    for (int j = 0; j &amp;lt; oldCap; ++j) {
        Node&amp;lt;K,V&amp;gt; e;
        if ((e = oldTab[j]) != null) {
            // 旧数组的桶下标赋给临时变量e，并且解除旧数组中的引用，否则就数组无法被GC回收
            oldTab[j] = null;
            // 如果e.next==null，代表桶中就一个元素，不存在链表或者红黑树
            if (e.next == null)
                // 用同样的hash映射算法把该元素加入新的数组
                newTab[e.hash &amp;amp; (newCap - 1)] = e;
            // 如果e是TreeNode并且e.next!=null，那么处理树中元素的重排
            else if (e instanceof TreeNode)
                ((TreeNode&amp;lt;K,V&amp;gt;)e).split(this, newTab, j, oldCap);
            // e是链表的头并且e.next!=null，那么处理链表中元素重排
            else { // preserve order
                // loHead,loTail 代表扩容后不用变换下标，见注1
                Node&amp;lt;K,V&amp;gt; loHead = null, loTail = null;
                // hiHead,hiTail 代表扩容后变换下标，见注1
                Node&amp;lt;K,V&amp;gt; hiHead = null, hiTail = null;
                Node&amp;lt;K,V&amp;gt; next;
                // 遍历链表
                do {             
                    next = e.next;
                    if ((e.hash &amp;amp; oldCap) == 0) {
                        if (loTail == null)
                            // 初始化head指向链表当前元素e，e不一定是链表的第一个元素，初始化后loHead
                            // 代表下标保持不变的链表的头元素
                            loHead = e;
                        else                                
                            // loTail.next指向当前e
                            loTail.next = e;
                        // loTail指向当前的元素e
                        // 初始化后，loTail和loHead指向相同的内存，所以当loTail.next指向下一个元素时，
                        // 底层数组中的元素的next引用也相应发生变化，造成lowHead.next.next.....
                        // 跟随loTail同步，使得lowHead可以链接到所有属于该链表的元素。
                        loTail = e;                           
                    }
                    else {
                        if (hiTail == null)
                            // 初始化head指向链表当前元素e, 初始化后hiHead代表下标更改的链表头元素
                            hiHead = e;
                        else
                            hiTail.next = e;
                        hiTail = e;
                    }
                } while ((e = next) != null);
                // 遍历结束, 将tail指向null，并把链表头放入新数组的相应下标，形成新的映射。
                if (loTail != null) {
                    loTail.next = null;
                    newTab[j] = loHead;
                }
                if (hiTail != null) {
                    hiTail.next = null;
                    newTab[j + oldCap] = hiHead;
                }
            }
        }
    }
}
return newTab;}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;hashmap是怎么解决哈希冲突的&#34;&gt;HashMap是怎么解决哈希冲突的？&lt;/h3&gt;
&lt;p&gt;答：在解决这个问题之前，我们首先需要知道 &lt;strong&gt;什么是哈希冲突&lt;/strong&gt; ，而在了解哈希冲突之前我们还要知道 &lt;strong&gt;什么是哈希&lt;/strong&gt; 才行；&lt;/p&gt;
&lt;h4 id=&#34;什么是哈希&#34;&gt;什么是哈希？&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;Hash&lt;/strong&gt;** ，一般翻译为&amp;quot;散列&amp;rdquo;，也有直接音译为&amp;quot;哈希&amp;quot;的，这就是把任意长度的输入通过散列算法，变换成固定长度的输出，该输出就是散列值（哈希值） &lt;strong&gt;；这种转换是一种压缩映射，也就是，散列值的空间通常远小于输入的空间，不同的输入可能会散列成相同的输出，所以不可能从散列值来唯一的确定输入值。&lt;/strong&gt; 简单的说就是一种将任意长度的消息压缩到某一固定长度的消息摘要的函数**。&lt;/p&gt;
&lt;p&gt;所有散列函数都有如下一个基本特性**：根据同一散列函数计算出的散列值如果不同，那么输入值肯定也不同。但是，根据同一散列函数计算出的散列值如果相同，输入值不一定相同**。&lt;/p&gt;
&lt;h4 id=&#34;什么是哈希冲突&#34;&gt;什么是哈希冲突？&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;当两个不同的输入值，根据同一散列函数计算出相同的散列值的现象，我们就把它叫做碰撞（哈希碰撞）&lt;/strong&gt; 。&lt;/p&gt;
&lt;h4 id=&#34;hashmap的数据结构&#34;&gt;HashMap的数据结构&lt;/h4&gt;
&lt;p&gt;在Java中，保存数据有两种比较简单的数据结构：数组和链表。 &lt;strong&gt;数组的特点是：寻址容易，插入和删除困难；链表的特点是：寻址困难，但插入和删除容易&lt;/strong&gt; ；所以我们将数组和链表结合在一起，发挥两者各自的优势，使用一种叫做 &lt;strong&gt;链地址法&lt;/strong&gt; 的方式可以解决哈希冲突：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cheneycqg.github.io/post/javacollectioncontainerinterviewquestions/8.jpg&#34;
	width=&#34;606&#34;
	height=&#34;279&#34;
	srcset=&#34;https://cheneycqg.github.io/post/javacollectioncontainerinterviewquestions/8_hu2cbe1461922f564086bffca627c47fd0_31077_480x0_resize_q75_box.jpg 480w, https://cheneycqg.github.io/post/javacollectioncontainerinterviewquestions/8_hu2cbe1461922f564086bffca627c47fd0_31077_1024x0_resize_q75_box.jpg 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;8&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;217&#34;
		data-flex-basis=&#34;521px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;这样我们就可以将拥有相同哈希值的对象组织成一个链表放在hash值所对应的bucket下， &lt;strong&gt;但相比于&lt;/strong&gt;** hashCode &lt;strong&gt;&lt;strong&gt;返回的&lt;/strong&gt;&lt;/strong&gt; int &lt;strong&gt;&lt;strong&gt;类型，我们&lt;/strong&gt;&lt;/strong&gt; HashMap &lt;strong&gt;&lt;strong&gt;初始的容量大小&lt;/strong&gt; DEFAULT_INITIAL_CAPACITY = 1 &amp;lt;&amp;lt; 4 &lt;strong&gt;（即&lt;/strong&gt;&lt;/strong&gt; 2 &lt;strong&gt;&lt;strong&gt;的四次方&lt;/strong&gt;&lt;/strong&gt; 16 &lt;strong&gt;&lt;strong&gt;）要远小于&lt;/strong&gt;&lt;/strong&gt; int &lt;strong&gt;&lt;strong&gt;类型的范围，所以我们如果只是单纯的用&lt;/strong&gt;&lt;/strong&gt; hashCode &lt;strong&gt;&lt;strong&gt;取余来获取对应的&lt;/strong&gt;&lt;/strong&gt; bucket &lt;strong&gt;&lt;strong&gt;这将会大大增加哈希碰撞的概率，并且最坏情况下还会将&lt;/strong&gt;&lt;/strong&gt; HashMap **&lt;strong&gt;变成一个单链表&lt;/strong&gt; ，所以我们还需要对hashCode作一定的优化&lt;/p&gt;
&lt;h4 id=&#34;hash函数&#34;&gt;hash()函数&lt;/h4&gt;
&lt;p&gt;上面提到的问题，主要是因为如果使用hashCode取余，那么相当于 &lt;strong&gt;参与运算的只有&lt;/strong&gt;** hashCode **&lt;strong&gt;的低位&lt;/strong&gt; ，高位是没有起到任何作用的，所以我们的思路就是让hashCode取值出的高位也参与运算，进一步降低hash碰撞的概率，使得数据分布更平均，我们把这样的操作称为 &lt;strong&gt;扰动&lt;/strong&gt; ，在 &lt;strong&gt;JDK 1.8&lt;/strong&gt; 中的hash()函数如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;staticfinalinthash(Object key){

	int h;

	return(key == null)?0:(h = key.hashCode())^(h &amp;gt;&amp;gt;&amp;gt;16);// 与自己右移16位进行异或运算（高低位异或）
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这比在 &lt;strong&gt;JDK 1.7&lt;/strong&gt; 中，更为简洁， &lt;strong&gt;相比在&lt;/strong&gt;** 1.7 &lt;strong&gt;&lt;strong&gt;中的&lt;/strong&gt;&lt;/strong&gt; 4 &lt;strong&gt;&lt;strong&gt;次位运算，&lt;/strong&gt;&lt;/strong&gt; 5 &lt;strong&gt;&lt;strong&gt;次异或运算（&lt;/strong&gt;&lt;/strong&gt; 9 &lt;strong&gt;&lt;strong&gt;次扰动），在&lt;/strong&gt;&lt;/strong&gt; 1.8 &lt;strong&gt;&lt;strong&gt;中，只进行了&lt;/strong&gt;&lt;/strong&gt; 1 &lt;strong&gt;&lt;strong&gt;次位运算和&lt;/strong&gt;&lt;/strong&gt; 1 &lt;strong&gt;&lt;strong&gt;次异或运算（&lt;/strong&gt;&lt;/strong&gt; 2 **&lt;strong&gt;次扰动）&lt;/strong&gt; ；&lt;/p&gt;
&lt;h4 id=&#34;jdk18新增红黑树&#34;&gt;JDK1.8新增红黑树&lt;/h4&gt;
&lt;p&gt;&lt;img src=&#34;https://cheneycqg.github.io/post/javacollectioncontainerinterviewquestions/9.jpg&#34;
	width=&#34;543&#34;
	height=&#34;411&#34;
	srcset=&#34;https://cheneycqg.github.io/post/javacollectioncontainerinterviewquestions/9_hud387d473298425f12a97bb4795969c08_31822_480x0_resize_q75_box.jpg 480w, https://cheneycqg.github.io/post/javacollectioncontainerinterviewquestions/9_hud387d473298425f12a97bb4795969c08_31822_1024x0_resize_q75_box.jpg 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;9&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;132&#34;
		data-flex-basis=&#34;317px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;通过上面的 &lt;strong&gt;链地址法（使用散列表）和扰动函数&lt;/strong&gt; 我们成功让我们的数据分布更平均，哈希碰撞减少，但是当我们的HashMap中存在大量数据时，加入我们某个bucket下对应的链表有n个元素，那么遍历时间复杂度就为O(n)，为了针对这个问题，JDK1.8在HashMap中新增了红黑树的数据结构，进一步使得遍历复杂度降低至O(logn)；&lt;/p&gt;
&lt;h4 id=&#34;总结&#34;&gt;总结&lt;/h4&gt;
&lt;p&gt;简单总结一下HashMap是使用了哪些方法来有效解决哈希冲突的：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1.&lt;/strong&gt;  &lt;strong&gt;使用链地址法（使用散列表）来链接拥有相同&lt;/strong&gt;** hash &lt;strong&gt;&lt;strong&gt;值的数据；&lt;/strong&gt;
&lt;strong&gt;2.&lt;/strong&gt;  &lt;strong&gt;使用&lt;/strong&gt;&lt;/strong&gt; 2 &lt;strong&gt;&lt;strong&gt;次扰动函数（&lt;/strong&gt;&lt;/strong&gt; hash **&lt;strong&gt;函数）来降低哈希冲突的概率，使得数据分布更平均；&lt;/strong&gt;
&lt;strong&gt;3.&lt;/strong&gt;  &lt;strong&gt;引入红黑树进一步降低遍历的时间复杂度，使得遍历更快；&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&#34;能否使用任何类作为-map-的-key&#34;&gt;能否使用任何类作为 Map 的 key？&lt;/h3&gt;
&lt;p&gt;可以使用任何类作为 Map 的 key，然而在使用之前，需要考虑以下几点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果类重写了 equals() 方法，也应该重写 hashCode() 方法。&lt;/li&gt;
&lt;li&gt;类的所有实例需要遵循与 equals() 和 hashCode() 相关的规则。&lt;/li&gt;
&lt;li&gt;如果一个类没有使用 equals()，不应该在 hashCode() 中使用它。&lt;/li&gt;
&lt;li&gt;用户自定义 Key 类最佳实践是使之为不可变的，这样 hashCode() 值可以被缓存起来，拥有更好的性能。不可变的类也可以确保 hashCode() 和 equals() 在未来不会改变，这样就会解决与可变相关的问题了。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;为什么hashmap中stringinteger这样的包装类适合作为k&#34;&gt;为什么HashMap中String、Integer这样的包装类适合作为K？&lt;/h3&gt;
&lt;p&gt;答：String、Integer等包装类的特性能够保证Hash值的不可更改性和计算准确性，能够有效的减少Hash碰撞的几率&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;都是final类型，即不可变性，保证key的不可更改性，不会存在获取hash值不同的情况&lt;/li&gt;
&lt;li&gt;内部已重写了equals()、hashCode()等方法，遵守了HashMap内部的规范（不清楚可以去上面看看putValue的过程），不容易出现Hash值计算错误的情况；&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;如果使用object作为hashmap的key应该怎么办呢&#34;&gt;如果使用Object作为HashMap的Key，应该怎么办呢？&lt;/h3&gt;
&lt;p&gt;答：重写hashCode()和equals()方法&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;重写&lt;/strong&gt; hashCode() &lt;strong&gt;是因为需要计算存储数据的存储位置&lt;/strong&gt; ，需要注意不要试图从散列码计算中排除掉一个对象的关键部分来提高性能，这样虽然能更快但可能会导致更多的Hash碰撞；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;重写&lt;/strong&gt; equals() &lt;strong&gt;方法&lt;/strong&gt; ，需要遵守自反性、对称性、传递性、一致性以及对于任何非null的引用值x，x.equals(null)必须返回false的这几个特性， &lt;strong&gt;目的是为了保证&lt;/strong&gt;** key **&lt;strong&gt;在哈希表中的唯一性&lt;/strong&gt; ；&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;hashmap为什么不直接使用hashcode处理后的哈希值直接作为table的下标&#34;&gt;HashMap为什么不直接使用hashCode()处理后的哈希值直接作为table的下标？&lt;/h3&gt;
&lt;p&gt;答：hashCode()方法返回的是int整数类型，其范围为-(2 ^ 31)~(2 ^ 31 - 1)，约有40亿个映射空间，而HashMap的容量范围是在16（初始化默认值）~2 ^ 30，HashMap通常情况下是取不到最大值的，并且设备上也难以提供这么多的存储空间，从而导致通过hashCode()计算出的哈希值可能不在数组大小范围内，进而无法匹配存储位置；&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;那怎么解决呢？&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;HashMap自己实现了自己的hash()方法，通过两次扰动使得它自己的哈希值高低位自行进行异或运算，降低哈希碰撞概率也使得数据分布更平均；&lt;/li&gt;
&lt;li&gt;在保证数组长度为2的幂次方的时候，使用hash()运算之后的值与运算（&amp;amp;）（数组长度 - 1）来获取数组下标的方式进行存储，这样一来是比取余操作更加有效率，二来也是因为只有当数组长度为2的幂次方时，h&amp;amp;(length-1)才等价于h%length，三来解决了&amp;quot;哈希值与数组大小范围不匹配&amp;quot;的问题；&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;hashmap-的长度为什么是2的幂次方&#34;&gt;HashMap 的长度为什么是2的幂次方&lt;/h3&gt;
&lt;p&gt;为了能让 HashMap 存取高效，尽量较少碰撞，也就是要尽量把数据分配均匀，每个链表/红黑树长度大致相同。这个实现就是把数据存到哪个链表/红黑树中的算法。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;这个算法应该如何设计呢？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我们首先可能会想到采用%取余的操作来实现。但是，重点来了：&amp;ldquo;取余(%)操作中如果除数是2的幂次则等价于与其除数减一的与(&amp;amp;)操作（也就是说 hash%length==hash&amp;amp;(length-1)的前提是 length 是2的 n 次方；）。&amp;rdquo; 并且 采用二进制位操作 &amp;amp;，相对于%能够提高运算效率，这就解释了 HashMap 的长度为什么是2的幂次方。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;那为什么是两次扰动呢？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;答：这样就是加大哈希值低位的随机性，使得分布更均匀，从而提高对应数组存储下标位置的随机性&amp;amp;均匀性，最终减少Hash冲突，两次就够了，已经达到了高位低位同时参与运算的目的；&lt;/p&gt;
&lt;h3 id=&#34;hashmap-与-hashtable-有什么区别&#34;&gt;HashMap 与 HashTable 有什么区别？&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;线程安全&lt;/strong&gt; ： HashMap 是非线程安全的，HashTable 是线程安全的；HashTable 内部的方法基本都经过 synchronized修饰。（如果你要保证线程安全的话就使用 ConcurrentHashMap 吧！）；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;效率&lt;/strong&gt; ： 因为线程安全的问题，HashMap 要比 HashTable 效率高一点。另外，HashTable 基本被淘汰，不要在代码中使用它；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;对&lt;/strong&gt;** Null key **** 和 &lt;strong&gt;&lt;strong&gt;Null value&lt;/strong&gt;&lt;/strong&gt; 的支持**： HashMap 中，null 可以作为键，这样的键只有一个，可以有一个或多个键所对应的值为 null。但是在 HashTable 中 put 进的键值只要有一个 null，直接抛NullPointerException。&lt;/li&gt;
&lt;li&gt;**初始容量大小和每次扩充容量大小的不同 **： ①创建时如果不指定容量初始值，Hashtable 默认的初始大小为11，之后每次扩充，容量变为原来的2n+1。HashMap 默认的初始化大小为16。之后每次扩充，容量变为原来的2倍。②创建时如果给定了容量初始值，那么 Hashtable 会直接使用你给定的大小，而 HashMap 会将其扩充为2的幂次方大小。也就是说 HashMap 总是使用2的幂作为哈希表的大小，后面会介绍到为什么是2的幂次方。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;底层数据结构&lt;/strong&gt; ： JDK1.8 以后的 HashMap 在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为8）时，将链表转化为红黑树，以减少搜索时间。Hashtable 没有这样的机制。&lt;/li&gt;
&lt;li&gt;推荐使用：在 Hashtable 的类注释可以看到，Hashtable 是保留类不建议使用，推荐在单线程环境下使用 HashMap 替代，如果需要多线程使用则用 ConcurrentHashMap 替代。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;如何决定使用-hashmap-还是-treemap&#34;&gt;如何决定使用 HashMap 还是 TreeMap？&lt;/h3&gt;
&lt;p&gt;对于在Map中插入、删除和定位元素这类操作，HashMap是最好的选择。然而，假如你需要对一个有序的key集合进行遍历，TreeMap是更好的选择。基于你的collection的大小，也许向HashMap中添加元素会更快，将map换为TreeMap进行有序key的遍历。&lt;/p&gt;
&lt;h3 id=&#34;hashmap-和-concurrenthashmap-的区别&#34;&gt;HashMap 和 ConcurrentHashMap 的区别&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;ConcurrentHashMap对整个桶数组进行了分割分段(Segment)，然后在每一个分段上都用lock锁进行保护，相对于HashTable的synchronized锁的粒度更精细了一些，并发性能更好，而HashMap没有锁机制，不是线程安全的。（JDK1.8之后ConcurrentHashMap启用了一种全新的方式实现,利用CAS算法。）&lt;/li&gt;
&lt;li&gt;HashMap的键值对允许有null，但是ConCurrentHashMap都不允许。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;concurrenthashmap-和-hashtable-的区别&#34;&gt;ConcurrentHashMap 和 Hashtable 的区别？&lt;/h3&gt;
&lt;p&gt;ConcurrentHashMap 和 Hashtable 的区别主要体现在实现线程安全的方式上不同。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;底层数据结构&lt;/strong&gt; ： JDK1.7的 ConcurrentHashMap 底层采用 &lt;strong&gt;分段的数组&lt;/strong&gt;** + &lt;strong&gt;&lt;strong&gt;链表&lt;/strong&gt; 实现，JDK1.8 采用的数据结构跟HashMap1.8的结构一样，数组+链表/红黑二叉树。Hashtable 和 JDK1.8 之前的 HashMap 的底层数据结构类似都是采用 &lt;strong&gt;数组&lt;/strong&gt;&lt;/strong&gt; + **&lt;strong&gt;链表&lt;/strong&gt; 的形式，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;实现线程安全的方式（重要）&lt;/strong&gt; ： ① &lt;strong&gt;在&lt;/strong&gt;** JDK1.7 &lt;strong&gt;&lt;strong&gt;的时候，&lt;/strong&gt;&lt;/strong&gt; ConcurrentHashMap &lt;strong&gt;&lt;strong&gt;（分段锁）&lt;/strong&gt; 对整个桶数组进行了分割分段(Segment)，每一把锁只锁容器其中一部分数据，多线程访问容器里不同数据段的数据，就不会存在锁竞争，提高并发访问率。（默认分配16个Segment，比Hashtable效率提高16倍。） &lt;strong&gt;到了&lt;/strong&gt;  &lt;strong&gt;JDK1.8&lt;/strong&gt;  &lt;strong&gt;的时候已经摒弃了&lt;/strong&gt;&lt;/strong&gt; Segment &lt;strong&gt;&lt;strong&gt;的概念，而是直接用&lt;/strong&gt;  &lt;strong&gt;Node&lt;/strong&gt;  &lt;strong&gt;数组&lt;/strong&gt;&lt;/strong&gt; + &lt;strong&gt;&lt;strong&gt;链表&lt;/strong&gt;&lt;/strong&gt; + &lt;strong&gt;&lt;strong&gt;红黑树的数据结构来实现，并发控制使用&lt;/strong&gt;  &lt;strong&gt;synchronized&lt;/strong&gt;  &lt;strong&gt;和&lt;/strong&gt;  &lt;strong&gt;CAS&lt;/strong&gt;  &lt;strong&gt;来操作。（&lt;/strong&gt;&lt;/strong&gt; JDK1.6 &lt;strong&gt;&lt;strong&gt;以后 对&lt;/strong&gt;  &lt;strong&gt;synchronized&lt;/strong&gt;&lt;/strong&gt; 锁做了很多优化） &lt;strong&gt;整个看起来就像是优化过且线程安全的 HashMap，虽然在JDK1.8中还能看到 Segment 的数据结构，但是已经简化了属性，只是为了兼容旧版本；②&lt;/strong&gt; Hashtable( &lt;strong&gt;&lt;strong&gt;同一把锁&lt;/strong&gt;&lt;/strong&gt; )** :使用 synchronized 来保证线程安全，效率非常低下。当一个线程访问同步方法时，其他线程也访问同步方法，可能会进入阻塞或轮询状态，如使用 put 添加元素，另一个线程不能使用 put 添加元素，也不能使用 get，竞争会越来越激烈效率越低。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;两者的对比图&lt;/strong&gt; ：&lt;/p&gt;
&lt;p&gt;HashTable:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cheneycqg.github.io/post/javacollectioncontainerinterviewquestions/10.jpg&#34;
	width=&#34;464&#34;
	height=&#34;346&#34;
	srcset=&#34;https://cheneycqg.github.io/post/javacollectioncontainerinterviewquestions/10_huc9332dff8193534a66bc95417e49ca49_44079_480x0_resize_q75_box.jpg 480w, https://cheneycqg.github.io/post/javacollectioncontainerinterviewquestions/10_huc9332dff8193534a66bc95417e49ca49_44079_1024x0_resize_q75_box.jpg 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;10&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;134&#34;
		data-flex-basis=&#34;321px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;JDK1.7的ConcurrentHashMap：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cheneycqg.github.io/post/javacollectioncontainerinterviewquestions/11.jpg&#34;
	width=&#34;555&#34;
	height=&#34;292&#34;
	srcset=&#34;https://cheneycqg.github.io/post/javacollectioncontainerinterviewquestions/11_hu0cdd85b6fc6e7ac728c8346d4d4b5357_61799_480x0_resize_q75_box.jpg 480w, https://cheneycqg.github.io/post/javacollectioncontainerinterviewquestions/11_hu0cdd85b6fc6e7ac728c8346d4d4b5357_61799_1024x0_resize_q75_box.jpg 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;11&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;190&#34;
		data-flex-basis=&#34;456px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;JDK1.8的ConcurrentHashMap（TreeBin: 红黑二叉树节点 Node: 链表节点）：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cheneycqg.github.io/post/javacollectioncontainerinterviewquestions/12.jpg&#34;
	width=&#34;507&#34;
	height=&#34;283&#34;
	srcset=&#34;https://cheneycqg.github.io/post/javacollectioncontainerinterviewquestions/12_hu89c3f490a85e14dcb2537c4e05b3fe0d_26337_480x0_resize_q75_box.jpg 480w, https://cheneycqg.github.io/post/javacollectioncontainerinterviewquestions/12_hu89c3f490a85e14dcb2537c4e05b3fe0d_26337_1024x0_resize_q75_box.jpg 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;12&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;179&#34;
		data-flex-basis=&#34;429px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;答：ConcurrentHashMap 结合了 HashMap 和 HashTable 二者的优势。HashMap 没有考虑同步，HashTable 考虑了同步的问题。但是 HashTable 在每次同步执行时都要锁住整个结构。 ConcurrentHashMap 锁的方式是稍微细粒度的。&lt;/p&gt;
&lt;h3 id=&#34;concurrenthashmap-底层具体实现知道吗实现原理是什么&#34;&gt;ConcurrentHashMap 底层具体实现知道吗？实现原理是什么？&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;JDK1.7&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;首先将数据分为一段一段的存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据时，其他段的数据也能被其他线程访问。&lt;/p&gt;
&lt;p&gt;在JDK1.7中，ConcurrentHashMap采用Segment + HashEntry的方式进行实现，结构如下：&lt;/p&gt;
&lt;p&gt;一个 ConcurrentHashMap 里包含一个 Segment 数组。Segment 的结构和HashMap类似，是一种数组和链表结构，一个 Segment 包含一个 HashEntry 数组，每个 HashEntry 是一个链表结构的元素，每个 Segment 守护着一个HashEntry数组里的元素，当对 HashEntry 数组的数据进行修改时，必须首先获得对应的 Segment的锁。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cheneycqg.github.io/post/javacollectioncontainerinterviewquestions/13.jpg&#34;
	width=&#34;440&#34;
	height=&#34;243&#34;
	srcset=&#34;https://cheneycqg.github.io/post/javacollectioncontainerinterviewquestions/13_hu9c4455246ba7c7dfc8db28476c457dcf_14440_480x0_resize_q75_box.jpg 480w, https://cheneycqg.github.io/post/javacollectioncontainerinterviewquestions/13_hu9c4455246ba7c7dfc8db28476c457dcf_14440_1024x0_resize_q75_box.jpg 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;13&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;181&#34;
		data-flex-basis=&#34;434px&#34;
	
&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;该类包含两个静态内部类 HashEntry 和 Segment ；前者用来封装映射表的键值对，后者用来充当锁的角色；&lt;/li&gt;
&lt;li&gt;Segment 是一种可重入的锁 ReentrantLock，每个 Segment 守护一个HashEntry 数组里得元素，当对 HashEntry 数组的数据进行修改时，必须首先获得对应的 Segment 锁。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;JDK1.8&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在 &lt;strong&gt;JDK1.8&lt;/strong&gt;** 中，放弃了 &lt;strong&gt;&lt;strong&gt;Segment&lt;/strong&gt;&lt;/strong&gt; 臃肿的设计，取而代之的是采用 &lt;strong&gt;&lt;strong&gt;Node + CAS + Synchronized&lt;/strong&gt;&lt;/strong&gt; 来保证并发安全进行实现**，synchronized只锁定当前链表或红黑二叉树的首节点，这样只要hash不冲突，就不会产生并发，效率又提升N倍。&lt;/p&gt;
&lt;p&gt;结构如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cheneycqg.github.io/post/javacollectioncontainerinterviewquestions/14.jpg&#34;
	width=&#34;475&#34;
	height=&#34;162&#34;
	srcset=&#34;https://cheneycqg.github.io/post/javacollectioncontainerinterviewquestions/14_hub1e57e2e6011ccc5fe730c5461e01d2f_8451_480x0_resize_q75_box.jpg 480w, https://cheneycqg.github.io/post/javacollectioncontainerinterviewquestions/14_hub1e57e2e6011ccc5fe730c5461e01d2f_8451_1024x0_resize_q75_box.jpg 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;14&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;293&#34;
		data-flex-basis=&#34;703px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;附加源码，有需要的可以看看&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;插入元素过程（建议去看看源码）：&lt;/p&gt;
&lt;p&gt;如果相应位置的Node还没有初始化，则调用CAS插入相应的数据；&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;elseif((f =tabAt(tab, i =(n -1)&amp;amp; hash))== null){

	if(casTabAt(tab, i, null,newNode&amp;lt;K,V&amp;gt;(hash, key, value, null)))

		break;// no lock when adding to empty bin
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果相应位置的Node不为空，且当前该节点不处于移动状态，则对该节点加synchronized锁，如果该节点的hash不小于0，则遍历链表更新节点或插入新节点；&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;if(fh &amp;gt;=0){
	binCount =1;
	for(Node&amp;lt;K,V&amp;gt; e = f;;++binCount){
		K ek;
		if(e.hash == hash &amp;amp;&amp;amp;((ek = e.key)== key ||(ek != null &amp;amp;&amp;amp; key.equals(ek)))){
			oldVal = e.val;
			if(!onlyIfAbsent)
				e.val = value;
			break;
		}
		Node&amp;lt;K,V&amp;gt; pred = e;
		if((e = e.next)== null){
			pred.next =newNode&amp;lt;K,V&amp;gt;(hash, key, value, null);
			break;
		}
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ol&gt;
&lt;li&gt;如果该节点是TreeBin类型的节点，说明是红黑树结构，则通过putTreeVal方法往红黑树中插入节点；如果binCount不为0，说明put操作对数据产生了影响，如果当前链表的个数达到8个，则通过treeifyBin方法转化为红黑树，如果oldVal不为空，说明是一次更新操作，没有对元素个数产生影响，则直接返回旧值；&lt;/li&gt;
&lt;li&gt;如果插入的是一个新节点，则执行addCount()方法尝试更新元素个数baseCount；&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;辅助工具类&#34;&gt;辅助工具类&lt;/h2&gt;
&lt;h3 id=&#34;array-和-arraylist-有何区别&#34;&gt;Array 和 ArrayList 有何区别？&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Array 可以存储基本数据类型和对象，ArrayList 只能存储对象。&lt;/li&gt;
&lt;li&gt;Array 是指定固定大小的，而 ArrayList 大小是自动扩展的。&lt;/li&gt;
&lt;li&gt;Array 内置方法没有 ArrayList 多，比如 addAll、removeAll、iteration 等方法只有 ArrayList 有。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;对于基本类型数据，集合使用自动装箱来减少编码工作量。但是，当处理固定大小的基本数据类型的时候，这种方式相对比较慢。&lt;/p&gt;
&lt;h3 id=&#34;如何实现-array-和-list-之间的转换&#34;&gt;如何实现 Array 和 List 之间的转换？&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Array 转 List： Arrays. asList(array) ；&lt;/li&gt;
&lt;li&gt;List 转 Array：List 的 toArray() 方法。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;comparable-和-comparator的区别&#34;&gt;comparable 和 comparator的区别？&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;comparable接口实际上是出自java.lang包，它有一个 compareTo(Object obj)方法用来排序&lt;/li&gt;
&lt;li&gt;comparator接口实际上是出自 java.util 包，它有一个compare(Object obj1, Object obj2)方法用来排序&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;一般我们需要对一个集合使用自定义排序时，我们就要重写compareTo方法或compare方法，当我们需要对某一个集合实现两种排序方式，比如一个song对象中的歌名和歌手名分别采用一种排序方法的话，我们可以重写compareTo方法和使用自制的Comparator方法或者以两个Comparator来实现歌名排序和歌星名排序，第二种代表我们只能使用两个参数版的Collections.sort().&lt;/p&gt;
&lt;h3 id=&#34;collection-和-collections-有什么区别&#34;&gt;Collection 和 Collections 有什么区别？&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;java.util.Collection 是一个集合接口（集合类的一个顶级接口）。它提供了对集合对象进行基本操作的通用接口方法。Collection接口在Java 类库中有很多具体的实现。Collection接口的意义是为各种具体的集合提供了最大化的统一操作方式，其直接继承接口有List与Set。&lt;/li&gt;
&lt;li&gt;Collections则是集合类的一个工具类/帮助类，其中提供了一系列静态方法，用于对集合中元素进行排序、搜索以及线程安全等各种操作。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;treemap-和-treeset-在排序时如何比较元素collections-工具类中的-sort方法如何比较元素&#34;&gt;TreeMap 和 TreeSet 在排序时如何比较元素？Collections 工具类中的 sort()方法如何比较元素？&lt;/h3&gt;
&lt;p&gt;TreeSet 要求存放的对象所属的类必须实现 Comparable 接口，该接口提供了比较元素的 compareTo()方法，当插入元素时会回调该方法比较元素的大小。TreeMap 要求存放的键值对映射的键必须实现 Comparable 接口从而根据键对元素进 行排 序。&lt;/p&gt;
&lt;p&gt;Collections 工具类的 sort 方法有两种重载的形式，&lt;/p&gt;
&lt;p&gt;第一种要求传入的待排序容器中存放的对象比较实现 Comparable 接口以实现元素的比较；&lt;/p&gt;
&lt;p&gt;第二种不强制性的要求容器中的元素必须可比较，但是要求传入第二个参数，参数是Comparator 接口的子类型（需要重写 compare 方法实现元素的比较），相当于一个临时定义的排序规则，其实就是通过接口注入比较元素大小的算法，也是对回调模式的应用（Java 中对函数式编程的支持）。&lt;/p&gt;</description>
        </item>
        <item>
        <title>01Java基础知识面试题</title>
        <link>https://cheneycqg.github.io/post/javabasicinterviewquestions/</link>
        <pubDate>Tue, 08 Aug 2023 00:00:00 +0000</pubDate>
        
        <guid>https://cheneycqg.github.io/post/javabasicinterviewquestions/</guid>
        <description>&lt;img src="https://cheneycqg.github.io/post/javabasicinterviewquestions/1.jpg" alt="Featured image of post 01Java基础知识面试题" /&gt;&lt;p&gt;Java基础知识面试题主要包括：Java介绍、基础语法、面向对象、IO流、反射、常用API等方面的知识。&lt;/p&gt;
&lt;h1 id=&#34;java&#34;&gt;Java&lt;/h1&gt;
&lt;h2 id=&#34;jvmjre和jdk的关系&#34;&gt;JVM、JRE和JDK的关系&lt;/h2&gt;
&lt;h3 id=&#34;jvm&#34;&gt;JVM&lt;/h3&gt;
&lt;p&gt;Java Virtual Machine是Java虚拟机，Java程序需要运行在虚拟机上，不同的平台有自己的虚拟机，因此Java语言可以实现跨平台。&lt;/p&gt;
&lt;h3 id=&#34;jre&#34;&gt;JRE&lt;/h3&gt;
&lt;p&gt;Java Runtime Environment包括Java虚拟机和Java程序所需的核心类库等。核心类库主要是java.lang包：包含了运行Java程序必不可少的系统类，如基本数据类型、基本数学函数、字符串处理、线程、异常处理类等，系统缺省加载这个包
如果想要运行一个开发好的Java程序，计算机中只需要安装JRE即可。&lt;/p&gt;
&lt;h3 id=&#34;jdk&#34;&gt;JDK&lt;/h3&gt;
&lt;p&gt;Java Development Kit是提供给Java开发人员使用的，其中包含了Java的开发工具，也包括了JRE。所以安装了JDK，就无需再单独安装JRE了。其中的开发工具：编译工具(javac.exe)，打包工具(jar.exe)等&lt;/p&gt;
&lt;p&gt;JVM&amp;amp;JRE&amp;amp;JDK关系图&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cheneycqg.github.io/post/javabasicinterviewquestions/2.jpg&#34;
	width=&#34;567&#34;
	height=&#34;345&#34;
	srcset=&#34;https://cheneycqg.github.io/post/javabasicinterviewquestions/2_hucaa92333e72601a6e262814b9d905c33_58419_480x0_resize_q75_box.jpg 480w, https://cheneycqg.github.io/post/javabasicinterviewquestions/2_hucaa92333e72601a6e262814b9d905c33_58419_1024x0_resize_q75_box.jpg 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;2&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;164&#34;
		data-flex-basis=&#34;394px&#34;
	
&gt;&lt;/p&gt;
&lt;h2 id=&#34;什么是跨平台性原理是什么&#34;&gt;什么是跨平台性？原理是什么&lt;/h2&gt;
&lt;p&gt;所谓跨平台性，是指java语言编写的程序，一次编译后，可以在多个系统平台上运行。&lt;/p&gt;
&lt;p&gt;实现原理：Java程序是通过java虚拟机在系统平台上运行的，只要该系统可以安装相应的java虚拟机，该系统就可以运行java程序。&lt;/p&gt;
&lt;h2 id=&#34;java语言有哪些特点&#34;&gt;Java语言有哪些特点&lt;/h2&gt;
&lt;p&gt;简单易学（Java语言的语法与C语言和C++语言很接近）&lt;/p&gt;
&lt;p&gt;面向对象（封装，继承，多态）&lt;/p&gt;
&lt;p&gt;平台无关性（Java虚拟机实现平台无关性）&lt;/p&gt;
&lt;p&gt;支持网络编程并且很方便（Java语言诞生本身就是为简化网络编程设计的）&lt;/p&gt;
&lt;p&gt;支持多线程（多线程机制使应用程序在同一时间并行执行多项任）&lt;/p&gt;
&lt;p&gt;健壮性（Java语言的强类型机制、异常处理、垃圾的自动收集等）&lt;/p&gt;
&lt;p&gt;安全性&lt;/p&gt;
&lt;h2 id=&#34;什么是字节码采用字节码的最大好处是什么&#34;&gt;什么是字节码？采用字节码的最大好处是什么&lt;/h2&gt;
&lt;h3 id=&#34;字节码&#34;&gt;字节码&lt;/h3&gt;
&lt;p&gt;Java源代码经过虚拟机编译器编译后产生的文件（即扩展为.class的文件），它不面向任何特定的处理器，只面向虚拟机。&lt;/p&gt;
&lt;h3 id=&#34;采用字节码的好处&#34;&gt;采用字节码的好处&lt;/h3&gt;
&lt;p&gt;Java语言通过字节码的方式，在一定程度上解决了传统解释型语言执行效率低的问题，同时又保留了解释型语言可移植的特点。所以Java程序运行时比较高效，而且，由于字节码并不专对一种特定的机器，因此，Java程序无须重新编译便可在多种不同的计算机上运行。&lt;/p&gt;
&lt;h3 id=&#34;先看下java中的编译器和解释器&#34;&gt;先看下java中的编译器和解释器&lt;/h3&gt;
&lt;p&gt;Java中引入了虚拟机的概念，即在机器和编译程序之间加入了一层抽象的虚拟机器。这台虚拟的机器在任何平台上都提供给编译程序一个的共同的接口。编译程序只需要面向虚拟机，生成虚拟机能够理解的代码，然后由解释器来将虚拟机代码转换为特定系统的机器码执行。在Java中，这种供虚拟机理解的代码叫做字节码（即扩展为.class的文件），它不面向任何特定的处理器，只面向虚拟机。每一种平台的解释器是不同的，但是实现的虚拟机是相同的。Java源程序经过编译器编译后变成字节码，字节码由虚拟机解释执行，虚拟机将每一条要执行的字节码送给解释器，解释器将其翻译成特定机器上的机器码，然后在特定的机器上运行，这就是上面提到的Java的特点的编译与解释并存的解释。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Java源代码----&amp;gt;编译器----&amp;gt;jvm可执行的Java字节码(即虚拟指令)----&amp;gt;jvm----&amp;gt;jvm中解释器-----&amp;gt;机器可执行的二进制机器码----&amp;gt;程序运行。
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;什么是java程序的主类应用程序和小程序的主类有何不同&#34;&gt;什么是Java程序的主类？应用程序和小程序的主类有何不同？&lt;/h2&gt;
&lt;p&gt;一个程序中可以有多个类，但只能有一个类是主类。在Java应用程序中，这个主类是指包含main()方法的类。而在Java小程序中，这个主类是一个继承自系统类JApplet或Applet的子类。应用程序的主类不一定要求是public类，但小程序的主类要求必须是public类。主类是Java程序执行的入口点。&lt;/p&gt;
&lt;h2 id=&#34;java应用程序与小程序之间有那些差别&#34;&gt;Java应用程序与小程序之间有那些差别？&lt;/h2&gt;
&lt;p&gt;简单说应用程序是从主线程启动(也就是main()方法)。applet小程序没有main方法，主要是嵌在浏览器页面上运行(调用init()线程或者run()来启动)，嵌入浏览器这点跟flash的小游戏类似。&lt;/p&gt;
&lt;h2 id=&#34;java和c的区别&#34;&gt;Java和C++的区别&lt;/h2&gt;
&lt;p&gt;我知道很多人没学过C++，但是面试官就是没事喜欢拿咱们Java和C++比呀！没办法！！！就算没学过C++，也要记下来！&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;都是面向对象的语言，都支持封装、继承和多态&lt;/li&gt;
&lt;li&gt;Java不提供指针来直接访问内存，程序内存更加安全&lt;/li&gt;
&lt;li&gt;Java的类是单继承的，C++支持多重继承；虽然Java的类不可以多继承，但是接口可以多继承。&lt;/li&gt;
&lt;li&gt;Java有自动内存管理机制，不需要程序员手动释放无用内存&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;oracle-jdk-和-openjdk-的对比&#34;&gt;Oracle JDK 和 OpenJDK 的对比&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;Oracle JDK版本将每三年发布一次，而OpenJDK版本每三个月发布一次；&lt;/li&gt;
&lt;li&gt;OpenJDK 是一个参考模型并且是完全开源的，而Oracle JDK是OpenJDK的一个实现，并不是完全开源的；&lt;/li&gt;
&lt;li&gt;Oracle JDK 比 OpenJDK 更稳定。OpenJDK和Oracle JDK的代码几乎相同，但Oracle JDK有更多的类和一些错误修复。因此，如果您想开发企业/商业软件，我建议您选择Oracle JDK，因为它经过了彻底的测试和稳定。某些情况下，有些人提到在使用OpenJDK 可能会遇到了许多应用程序崩溃的问题，但是，只需切换到Oracle JDK就可以解决问题；&lt;/li&gt;
&lt;li&gt;在响应性和JVM性能方面，Oracle JDK与OpenJDK相比提供了更好的性能；&lt;/li&gt;
&lt;li&gt;Oracle JDK不会为即将发布的版本提供长期支持，用户每次都必须通过更新到最新版本获得支持来获取最新版本；&lt;/li&gt;
&lt;li&gt;Oracle JDK根据二进制代码许可协议获得许可，而OpenJDK根据GPL v2许可获得许可。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;基础语法&#34;&gt;基础语法&lt;/h2&gt;
&lt;h3 id=&#34;数据类型&#34;&gt;数据类型&lt;/h3&gt;
&lt;h4 id=&#34;java有哪些数据类型&#34;&gt;Java有哪些数据类型&lt;/h4&gt;
&lt;h5 id=&#34;定义&#34;&gt;定义&lt;/h5&gt;
&lt;p&gt;Java语言是强类型语言，对于每一种数据都定义了明确的具体的数据类型，在内存中分配了不同大小的内存空间。&lt;/p&gt;
&lt;h5 id=&#34;分类&#34;&gt;分类&lt;/h5&gt;
&lt;p&gt;•	基本数据类型&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;数值型&lt;/li&gt;
&lt;li&gt;整数类型(byte,short,int,long)&lt;/li&gt;
&lt;li&gt;浮点类型(float,double)&lt;/li&gt;
&lt;li&gt;字符型(char)&lt;/li&gt;
&lt;li&gt;布尔型(boolean)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;•	引用数据类型&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;类(class)&lt;/li&gt;
&lt;li&gt;接口(interface)&lt;/li&gt;
&lt;li&gt;数组([])&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;java基本数据类型图&#34;&gt;Java基本数据类型图&lt;/h5&gt;
&lt;p&gt;&lt;img src=&#34;https://cheneycqg.github.io/post/javabasicinterviewquestions/3.jpg&#34;
	width=&#34;567&#34;
	height=&#34;182&#34;
	srcset=&#34;https://cheneycqg.github.io/post/javabasicinterviewquestions/3_huc9d12f02792c07ff970f7f2d1064b33e_101207_480x0_resize_q75_box.jpg 480w, https://cheneycqg.github.io/post/javabasicinterviewquestions/3_huc9d12f02792c07ff970f7f2d1064b33e_101207_1024x0_resize_q75_box.jpg 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;3&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;311&#34;
		data-flex-basis=&#34;747px&#34;
	
&gt;&lt;/p&gt;
&lt;h4 id=&#34;switch-是否能作用在-byte-上是否能作用在-long-上是否能作用在-string-上&#34;&gt;switch 是否能作用在 byte 上，是否能作用在 long 上，是否能作用在 String 上&lt;/h4&gt;
&lt;p&gt;在 Java 5 以前，switch(expr)中，expr 只能是 byte、short、char、int。从 Java5 开始，Java 中引入了枚举类型，expr 也可以是 enum 类型，从 Java 7 开始，expr 还可以是字符串（String），但是长整型（long）在目前所有的版本中都是不可以的。&lt;/p&gt;
&lt;h4 id=&#34;用最有效率的方法计算-2-乘以-8&#34;&gt;用最有效率的方法计算 2 乘以 8&lt;/h4&gt;
&lt;p&gt;2 &amp;laquo; 3（左移 3 位相当于乘以 2 的 3 次方，右移 3 位相当于除以 2 的 3 次方）。&lt;/p&gt;
&lt;h4 id=&#34;mathround115-等于多少mathround-115等于多少&#34;&gt;Math.round(11.5) 等于多少？Math.round(-11.5)等于多少&lt;/h4&gt;
&lt;p&gt;Math.round(11.5)的返回值是 12，Math.round(-11.5)的返回值是-11。四舍五入的原理是在参数上加 0.5 然后进行下取整。&lt;/p&gt;
&lt;h4 id=&#34;float-f34是否正确&#34;&gt;float f=3.4;是否正确&lt;/h4&gt;
&lt;p&gt;不正确。3.4 是双精度数，将双精度型（double）赋值给浮点型（float）属于下转型（down-casting，也称为窄化）会造成精度损失，因此需要强制类型转换float f =(float)3.4; 或者写成 float f =3.4F;。&lt;/p&gt;
&lt;h4 id=&#34;short-s1--1-s1--s1--1有错吗short-s1--1-s1--1有错吗&#34;&gt;short s1 = 1; s1 = s1 + 1;有错吗?short s1 = 1; s1 += 1;有错吗&lt;/h4&gt;
&lt;p&gt;对于 short s1 = 1; s1 = s1 + 1;由于 1 是 int 类型，因此 s1+1 运算结果也是 int型，需要强制转换类型才能赋值给 short 型。&lt;/p&gt;
&lt;p&gt;而 short s1 = 1; s1 += 1;可以正确编译，因为 s1+= 1;相当于 s1 = (short(s1 + 1);其中有隐含的强制类型转换。&lt;/p&gt;
&lt;h3 id=&#34;编码&#34;&gt;编码&lt;/h3&gt;
&lt;h4 id=&#34;java语言采用何种编码方案有何特点&#34;&gt;Java语言采用何种编码方案？有何特点？&lt;/h4&gt;
&lt;p&gt;Java语言采用Unicode编码标准，Unicode（标准码），它为每个字符制订了一个唯一的数值，因此在任何的语言，平台，程序都可以放心的使用。&lt;/p&gt;
&lt;h3 id=&#34;注释&#34;&gt;注释&lt;/h3&gt;
&lt;h4 id=&#34;什么java注释&#34;&gt;什么Java注释&lt;/h4&gt;
&lt;h5 id=&#34;定义-1&#34;&gt;定义&lt;/h5&gt;
&lt;p&gt;用于解释说明程序的文字&lt;/p&gt;
&lt;h5 id=&#34;分类-1&#34;&gt;分类&lt;/h5&gt;
&lt;p&gt;•	单行注释
格式： // 注释文字&lt;/p&gt;
&lt;p&gt;•	多行注释
格式： /* 注释文字 */&lt;/p&gt;
&lt;p&gt;•	文档注释
格式：/** 注释文字 */&lt;/p&gt;
&lt;h5 id=&#34;作用&#34;&gt;作用&lt;/h5&gt;
&lt;p&gt;在程序中，尤其是复杂的程序中，适当地加入注释可以增加程序的可读性，有利于程序的修改、调试和交流。注释的内容在程序编译的时候会被忽视，不会产生目标代码，注释的部分不会对程序的执行结果产生任何影响。&lt;/p&gt;
&lt;h5 id=&#34;注意事项&#34;&gt;注意事项&lt;/h5&gt;
&lt;p&gt;多行和文档注释都不能嵌套使用。&lt;/p&gt;
&lt;h3 id=&#34;访问修饰符&#34;&gt;访问修饰符&lt;/h3&gt;
&lt;h4 id=&#34;访问修饰符-publicprivateprotected以及不写默认时的区别&#34;&gt;访问修饰符 public,private,protected,以及不写（默认）时的区别&lt;/h4&gt;
&lt;h5 id=&#34;定义-2&#34;&gt;定义&lt;/h5&gt;
&lt;p&gt;Java中，可以使用访问修饰符来保护对类、变量、方法和构造方法的访问。Java 支持 4 种不同的访问权限。&lt;/p&gt;
&lt;h5 id=&#34;分类-2&#34;&gt;分类&lt;/h5&gt;
&lt;p&gt;private : 在同一类内可见。使用对象：变量、方法。 注意：不能修饰类（外部类）&lt;/p&gt;
&lt;p&gt;default (即缺省，什么也不写，不使用任何关键字）: 在同一包内可见，不使用任何修饰符。使用对象：类、接口、变量、方法。&lt;/p&gt;
&lt;p&gt;protected : 对同一包内的类和所有子类可见。使用对象：变量、方法。 注意：不能修饰类（外部类）。&lt;/p&gt;
&lt;p&gt;public : 对所有类可见。使用对象：类、接口、变量、方法&lt;/p&gt;
&lt;h5 id=&#34;访问修饰符图&#34;&gt;访问修饰符图&lt;/h5&gt;
&lt;p&gt;&lt;img src=&#34;https://cheneycqg.github.io/post/javabasicinterviewquestions/4.jpg&#34;
	width=&#34;520&#34;
	height=&#34;141&#34;
	srcset=&#34;https://cheneycqg.github.io/post/javabasicinterviewquestions/4_hu87e70d8919834ee94c76f83dd80ecad3_9889_480x0_resize_q75_box.jpg 480w, https://cheneycqg.github.io/post/javabasicinterviewquestions/4_hu87e70d8919834ee94c76f83dd80ecad3_9889_1024x0_resize_q75_box.jpg 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;4&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;368&#34;
		data-flex-basis=&#34;885px&#34;
	
&gt;&lt;/p&gt;
&lt;h3 id=&#34;运算符&#34;&gt;运算符&lt;/h3&gt;
&lt;h4 id=&#34;和的区别&#34;&gt;&amp;amp;和&amp;amp;&amp;amp;的区别&lt;/h4&gt;
&lt;p&gt;&amp;amp;运算符有两种用法：(1)按位与；(2)逻辑与。&lt;/p&gt;
&lt;p&gt;&amp;amp;&amp;amp;运算符是短路与运算。逻辑与跟短路与的差别是非常巨大的，虽然二者都要求运算符左右两端的布尔值都是true 整个表达式的值才是 true。&amp;amp;&amp;amp;之所以称为短路运算，是因为如果&amp;amp;&amp;amp;左边的表达式的值是 false，右边的表达式会被直接短路掉，不会进行运算。&lt;/p&gt;
&lt;h4 id=&#34;注意&#34;&gt;注意&lt;/h4&gt;
&lt;p&gt;逻辑或运算符（|）和短路或运算符（||）的差别也是如此。&lt;/p&gt;
&lt;h3 id=&#34;关键字&#34;&gt;关键字&lt;/h3&gt;
&lt;h4 id=&#34;java-有没有-goto&#34;&gt;Java 有没有 goto&lt;/h4&gt;
&lt;p&gt;goto 是 Java 中的保留字，在目前版本的 Java 中没有使用。&lt;/p&gt;
&lt;h4 id=&#34;final-有什么用&#34;&gt;final 有什么用？&lt;/h4&gt;
&lt;p&gt;用于修饰类、属性和方法；&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;被final修饰的类不可以被继承&lt;/li&gt;
&lt;li&gt;被final修饰的方法不可以被重写&lt;/li&gt;
&lt;li&gt;被final修饰的变量不可以被改变，被final修饰不可变的是变量的引用，而不是引用指向的内容，引用指向的内容是可以改变的&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;final-finally-finalize区别&#34;&gt;final finally finalize区别&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;final可以修饰类、变量、方法，修饰类表示该类不能被继承、修饰方法表示该方法不能被重写、修饰变量表示该变量是一个常量不能被重新赋值。&lt;/li&gt;
&lt;li&gt;finally一般作用在try-catch代码块中，在处理异常的时候，通常我们将一定要执行的代码方法finally代码块中，表示不管是否出现异常，该代码块都会执行，一般用来存放一些关闭资源的代码。&lt;/li&gt;
&lt;li&gt;finalize是一个方法，属于Object类的一个方法，而Object类是所有类的父类，该方法一般由垃圾回收器来调用，当我们调用System.gc() 方法的时候，由垃圾回收器调用finalize()，回收垃圾，一个对象是否可回收的最后判断。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;this关键字的用法&#34;&gt;this关键字的用法&lt;/h4&gt;
&lt;p&gt;this是自身的一个对象，代表对象本身，可以理解为：指向对象本身的一个指针。
this的用法在java中大体可以分为3种：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;普通的直接引用，this相当于是指向当前对象本身。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;形参与成员名字重名，用this来区分&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; public Person(String name, int age) {
    this.name = name;
    this.age = age;}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;引用本类的构造函数&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; class Person{
 	private String name;
			private int age;

 	public Person() {
 	}

 	public Person(String name) {
 		this.name = name;
 	}
 	public Person(String name, int age) {
 		this(name);
 		this.age = age;
 }}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;super关键字的用法&#34;&gt;super关键字的用法&lt;/h4&gt;
&lt;p&gt;super可以理解为是指向自己超（父）类对象的一个指针，而这个超类指的是离自己最近的一个父类。
super也有三种用法：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;普通的直接引用:
与this类似，super相当于是指向当前对象的父类的引用，这样就可以用super.xxx来引用父类的成员。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;子类中的成员变量或方法与父类中的成员变量或方法同名时，用super进行区分&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; class Person{
 	protected String name;

 	public Person(String name) {
 		this.name = name;
 	}
 }
 class Student extends Person{
 	private String name;

 	public Student(String name, String name1) {
 		super(name);
 		this.name = name1;
 	}

 	public void getInfo(){
 		System.out.println(this.name);  //Child
 		System.out.println(super.name); //Father
 	}
 }
 public class Test {
 	public static void main(String[] args) {
			Student s1 = new Student(&amp;quot;Father&amp;quot;,&amp;quot;Child&amp;quot;);
			s1.getInfo();
 }}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;引用父类构造函数&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;super（参数）：调用父类中的某一个构造函数（应该为构造函数中的第一条语句）。&lt;/p&gt;
&lt;p&gt;this（参数）：调用本类中另一种形式的构造函数（应该为构造函数中的第一条语句）。&lt;/p&gt;
&lt;h4 id=&#34;this与super的区别&#34;&gt;this与super的区别&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;super:　它引用当前对象的直接父类中的成员（用来访问直接父类中被隐藏的父类中成员数据或函数，基类与派生类中有相同成员定义时如：super.变量名 super.成员函数据名（实参）&lt;/li&gt;
&lt;li&gt;this：它代表当前对象名（在程序中易产生二义性之处，应使用this来指明当前对象；如果函数的形参与类中的成员数据同名，这时需用this来指明成员变量名）&lt;/li&gt;
&lt;li&gt;super()和this()类似,区别是，super()在子类中调用父类的构造方法，this()在本类内调用本类的其它构造方法。&lt;/li&gt;
&lt;li&gt;super()和this()均需放在构造方法内第一行。&lt;/li&gt;
&lt;li&gt;尽管可以用this调用一个构造器，但却不能调用两个。&lt;/li&gt;
&lt;li&gt;this和super不能同时出现在一个构造函数里面，因为this必然会调用其它的构造函数，其它的构造函数必然也会有super语句的存在，所以在同一个构造函数里面有相同的语句，就失去了语句的意义，编译器也不会通过。&lt;/li&gt;
&lt;li&gt;this()和super()都指的是对象，所以，均不可以在static环境中使用。包括：static变量,static方法，static语句块。&lt;/li&gt;
&lt;li&gt;从本质上讲，this是一个指向本对象的指针, 然而super是一个Java关键字。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;static存在的主要意义&#34;&gt;static存在的主要意义&lt;/h4&gt;
&lt;p&gt;static的主要意义是在于创建独立于具体对象的域变量或者方法。以致于即使没有创建对象，也能使用属性和调用方法！&lt;/p&gt;
&lt;p&gt;static关键字还有一个比较关键的作用就是 用来形成静态代码块以优化程序性能。static块可以置于类中的任何地方，类中可以有多个static块。在类初次被加载的时候，会按照static块的顺序来执行每个static块，并且只会执行一次。&lt;/p&gt;
&lt;p&gt;为什么说static块可以用来优化程序性能，是因为它的特性:只会在类加载的时候执行一次。因此，很多时候会将一些只需要进行一次的初始化操作都放在static代码块中进行。&lt;/p&gt;
&lt;h4 id=&#34;static的独特之处&#34;&gt;static的独特之处&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;被static修饰的变量或者方法是独立于该类的任何对象，也就是说，这些变量和方法不属于任何一个实例对象，而是被类的实例对象所共享。&lt;/li&gt;
&lt;li&gt;怎么理解 “被类的实例对象所共享” 这句话呢？就是说，一个类的静态成员，它是属于大伙的【大伙指的是这个类的多个对象实例，我们都知道一个类可以创建多个实例！】，所有的类对象共享的，不像成员变量是自个的【自个指的是这个类的单个实例对象】…我觉得我已经讲的很通俗了，你明白了咩？&lt;/li&gt;
&lt;li&gt;在该类被第一次加载的时候，就会去加载被static修饰的部分，而且只在类第一次使用时加载并进行初始化，注意这是第一次用就要初始化，后面根据需要是可以再次赋值的。&lt;/li&gt;
&lt;li&gt;static变量值在类加载的时候分配空间，以后创建类对象的时候不会重新分配。赋值的话，是可以任意赋值的！&lt;/li&gt;
&lt;li&gt;被static修饰的变量或者方法是优先于对象存在的，也就是说当一个类加载完毕之后，即便没有创建对象，也可以去访问。&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;static应用场景&#34;&gt;static应用场景&lt;/h4&gt;
&lt;p&gt;因为static是被类的实例对象所共享，因此如果某个成员变量是被所有对象所共享的，那么这个成员变量就应该定义为静态变量。&lt;/p&gt;
&lt;p&gt;因此比较常见的static应用场景有：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;修饰成员变量&lt;/li&gt;
&lt;li&gt;修饰成员方法&lt;/li&gt;
&lt;li&gt;静态代码块&lt;/li&gt;
&lt;li&gt;修饰类【只能修饰内部类也就是静态内部类】&lt;/li&gt;
&lt;li&gt;静态导包&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;static注意事项&#34;&gt;static注意事项&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;静态只能访问静态。&lt;/li&gt;
&lt;li&gt;非静态既可以访问非静态的，也可以访问静态的。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;流程控制语句&#34;&gt;流程控制语句&lt;/h3&gt;
&lt;h4 id=&#34;break-continue-return-的区别及作用&#34;&gt;break ,continue ,return 的区别及作用&lt;/h4&gt;
&lt;p&gt;break 跳出总上一层循环，不再执行循环(结束当前的循环体)&lt;/p&gt;
&lt;p&gt;continue 跳出本次循环，继续执行下次循环(结束正在执行的循环 进入下一个循环条件)&lt;/p&gt;
&lt;p&gt;return 程序返回，不再执行下面的代码(结束当前的方法 直接返回)&lt;/p&gt;
&lt;h4 id=&#34;在-java-中如何跳出当前的多重嵌套循环&#34;&gt;在 Java 中，如何跳出当前的多重嵌套循环&lt;/h4&gt;
&lt;p&gt;在Java中，要想跳出多重循环，可以在外面的循环语句前定义一个标号，然后在里层循环体的代码中使用带有标号的break 语句，即可跳出外层循环。例如：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public static void main(String[] args) {
	ok:
	for (int i = 0; i &amp;lt; 10; i++) {
    	for (int j = 0; j &amp;lt; 10; j++) {
        	System.out.println(&amp;quot;i=&amp;quot; + i + &amp;quot;,j=&amp;quot; + j);
        	if (j == 5) {
            	break ok;
        	}
    	}
	}}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;面向对象&#34;&gt;面向对象&lt;/h2&gt;
&lt;h3 id=&#34;面向对象概述&#34;&gt;面向对象概述&lt;/h3&gt;
&lt;h4 id=&#34;面向对象和面向过程的区别&#34;&gt;面向对象和面向过程的区别&lt;/h4&gt;
&lt;h5 id=&#34;面向过程&#34;&gt;面向过程&lt;/h5&gt;
&lt;p&gt;优点：性能比面向对象高，因为类调用时需要实例化，开销比较大，比较消耗资源;比如单片机、嵌入式开发、Linux/Unix等一般采用面向过程开发，性能是最重要的因素。&lt;/p&gt;
&lt;p&gt;缺点：没有面向对象易维护、易复用、易扩展&lt;/p&gt;
&lt;h5 id=&#34;面向对象-1&#34;&gt;面向对象：&lt;/h5&gt;
&lt;p&gt;优点：易维护、易复用、易扩展，由于面向对象有封装、继承、多态性的特性，可以设计出低耦合的系统，使系统更加灵活、更加易于维护&lt;/p&gt;
&lt;p&gt;缺点：性能比面向过程低&lt;/p&gt;
&lt;p&gt;**面向过程是具体化的，流程化的，解决一个问题，你需要一步一步的分析，一步一步的实现。&lt;/p&gt;
&lt;p&gt;面向对象是模型化的，你只需抽象出一个类，这是一个封闭的盒子，在这里你拥有数据也拥有解决问题的方法。需要什么功能直接使用就可以了，不必去一步一步的实现，至于这个功能是如何实现的，管我们什么事？我们会用就可以了。**&lt;/p&gt;
&lt;p&gt;面向对象的底层其实还是面向过程，把面向过程抽象成类，然后封装，方便我们使用的就是面向对象了。&lt;/p&gt;
&lt;h3 id=&#34;面向对象三大特性&#34;&gt;面向对象三大特性&lt;/h3&gt;
&lt;h4 id=&#34;面向对象的特征有哪些方面&#34;&gt;面向对象的特征有哪些方面&lt;/h4&gt;
&lt;h4 id=&#34;面向对象的特征主要有以下几个方面&#34;&gt;面向对象的特征主要有以下几个方面&lt;/h4&gt;
&lt;h5 id=&#34;抽象&#34;&gt;抽象&lt;/h5&gt;
&lt;p&gt;抽象是将一类对象的共同特征总结出来构造类的过程，包括数据抽象和行为抽象两方面。抽象只关注对象有哪些属性和行为，并不关注这些行为的细节是什么。&lt;/p&gt;
&lt;h5 id=&#34;封装&#34;&gt;封装&lt;/h5&gt;
&lt;p&gt;封装把一个对象的属性私有化，同时提供一些可以被外界访问的属性的方法，如果属性不想被外界访问，我们大可不必提供方法给外界访问。但是如果一个类没有提供给外界访问的方法，那么这个类也没有什么意义了。&lt;/p&gt;
&lt;h5 id=&#34;继承&#34;&gt;继承&lt;/h5&gt;
&lt;p&gt;继承是使用已存在的类的定义作为基础建立新类的技术，新类的定义可以增加新的数据或新的功能，也可以用父类的功能，但不能选择性地继承父类。通过使用继承我们能够非常方便地复用以前的代码。&lt;/p&gt;
&lt;p&gt;关于继承如下 3 点请记住：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;子类拥有父类非 private 的属性和方法。&lt;/li&gt;
&lt;li&gt;子类可以拥有自己属性和方法，即子类可以对父类进行扩展。&lt;/li&gt;
&lt;li&gt;子类可以用自己的方式实现父类的方法。（以后介绍）。&lt;/li&gt;
&lt;/ol&gt;
&lt;h5 id=&#34;多态&#34;&gt;多态&lt;/h5&gt;
&lt;p&gt;所谓多态就是指程序中定义的引用变量所指向的具体类型和通过该引用变量发出的方法调用在编程时并不确定，而是在程序运行期间才确定，即一个引用变量到底会指向哪个类的实例对象，该引用变量发出的方法调用到底是哪个类中实现的方法，必须在由程序运行期间才能决定。&lt;/p&gt;
&lt;p&gt;在Java中有两种形式可以实现多态：继承（多个子类对同一方法的重写）和接口（实现接口并覆盖接口中同一方法）。&lt;/p&gt;
&lt;p&gt;其中Java 面向对象编程三大特性：封装 继承 多态
封装：隐藏对象的属性和实现细节，仅对外提供公共访问方式，将变化隔离，便于使用，提高复用性和安全性。&lt;/p&gt;
&lt;p&gt;继承：继承是使用已存在的类的定义作为基础建立新类的技术，新类的定义可以增加新的数据或新的功能，也可以用父类的功能，但不能选择性地继承父类。通过使用继承可以提高代码复用性。继承是多态的前提。&lt;/p&gt;
&lt;p&gt;多态性：父类或接口定义的引用变量可以指向子类或具体实现类的实例对象。提高了程序的拓展性。&lt;/p&gt;
&lt;p&gt;在Java中有两种形式可以实现多态：继承（多个子类对同一方法的重写）和接口（实现接口并覆盖接口中同一方法）。&lt;/p&gt;
&lt;p&gt;方法重载（overload）实现的是编译时的多态性（也称为前绑定）&lt;/p&gt;
&lt;p&gt;方法重写（override）实现的是运行时的多态性（也称为后绑定）&lt;/p&gt;
&lt;p&gt;一个引用变量到底会指向哪个类的实例对象，该引用变量发出的方法调用到底是哪个类中实现的方法，必须在由程序运行期间才能决定。运行时的多态是面向对象最精髓的东西，要实现多态需要做两件事：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;方法重写（子类继承父类并重写父类中已有的或抽象的方法）&lt;/li&gt;
&lt;li&gt;对象造型（用父类型引用子类型对象，这样同样的引用调用同样的方法就会根据子类对象的不同而表现出不同的行为）。&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;什么是多态机制java语言是如何实现多态的&#34;&gt;什么是多态机制？Java语言是如何实现多态的？&lt;/h5&gt;
&lt;p&gt;所谓多态就是指程序中定义的引用变量所指向的具体类型和通过该引用变量发出的方法调用在编程时并不确定，而是在程序运行期间才确定，即一个引用变量倒底会指向哪个类的实例对象，该引用变量发出的方法调用到底是哪个类中实现的方法，必须在由程序运行期间才能决定。因为在程序运行时才确定具体的类，这样，不用修改源程序代码，就可以让引用变量绑定到各种不同的类实现上，从而导致该引用调用的具体方法随之改变，即不修改程序代码就可以改变程序运行时所绑定的具体代码，让程序可以选择多个运行状态，这就是多态性。&lt;/p&gt;
&lt;p&gt;多态分为编译时多态和运行时多态。其中编辑时多态是静态的，主要是指方法的重载，它是根据参数列表的不同来区分不同的函数，通过编辑之后会变成两个不同的函数，在运行时谈不上多态。而运行时多态是动态的，它是通过动态绑定来实现的，也就是我们所说的多态性。&lt;/p&gt;
&lt;h5 id=&#34;多态的实现&#34;&gt;多态的实现&lt;/h5&gt;
&lt;p&gt;Java实现多态有三个必要条件：继承、重写、向上转型。&lt;/p&gt;
&lt;p&gt;继承：在多态中必须存在有继承关系的子类和父类。&lt;/p&gt;
&lt;p&gt;重写：子类对父类中某些方法进行重新定义，在调用这些方法时就会调用子类的方法。&lt;/p&gt;
&lt;p&gt;向上转型：在多态中需要将子类的引用赋给父类对象，只有这样该引用才能够具备技能调用父类的方法和子类的方法。&lt;/p&gt;
&lt;p&gt;只有满足了上述三个条件，我们才能够在同一个继承结构中使用统一的逻辑实现代码处理不同的对象，从而达到执行不同的行为。&lt;/p&gt;
&lt;p&gt;对于Java而言，它多态的实现机制遵循一个原则：当超类对象引用变量引用子类对象时，被引用对象的类型而不是引用变量的类型决定了调用谁的成员方法，但是这个被调用的方法必须是在超类中定义过的，也就是说被子类覆盖的方法。&lt;/p&gt;
&lt;h4 id=&#34;面向对象五大基本原则是什么可选&#34;&gt;面向对象五大基本原则是什么（可选）&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;单一职责原则SRP(Single Responsibility Principle)类的功能要单一，不能包罗万象，跟杂货铺似的。&lt;/li&gt;
&lt;li&gt;开放封闭原则OCP(Open－Close Principle)一个模块对于拓展是开放的，对于修改是封闭的，想要增加功能热烈欢迎，想要修改，哼，一万个不乐意。&lt;/li&gt;
&lt;li&gt;里式替换原则LSP(the Liskov Substitution Principle LSP)子类可以替换父类出现在父类能够出现的任何地方。比如你能代表你爸去你姥姥家干活。哈哈~~&lt;/li&gt;
&lt;li&gt;依赖倒置原则DIP(the Dependency Inversion Principle DIP)高层次的模块不应该依赖于低层次的模块，他们都应该依赖于抽象。抽象不应该依赖于具体实现，具体实现应该依赖于抽象。就是你出国要说你是中国人，而不能说你是哪个村子的。比如说中国人是抽象的，下面有具体的xx省，xx市，xx县。你要依赖的抽象是中国人，而不是你是xx村的。&lt;/li&gt;
&lt;li&gt;接口分离原则ISP(the Interface Segregation Principle ISP)
设计时采用多个与特定客户类有关的接口比采用一个通用的接口要好。就比如一个手机拥有打电话，看视频，玩游戏等功能，把这几个功能拆分成不同的接口，比在一个接口里要好的多。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;类与接口&#34;&gt;类与接口&lt;/h3&gt;
&lt;h4 id=&#34;抽象类和接口的对比&#34;&gt;抽象类和接口的对比&lt;/h4&gt;
&lt;p&gt;抽象类是用来捕捉子类的通用特性的。接口是抽象方法的集合。&lt;/p&gt;
&lt;p&gt;从设计层面来说，抽象类是对类的抽象，是一种模板设计，接口是行为的抽象，是一种行为的规范。&lt;/p&gt;
&lt;h4 id=&#34;相同点&#34;&gt;相同点&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;接口和抽象类都不能实例化&lt;/li&gt;
&lt;li&gt;都位于继承的顶端，用于被其他实现或继承&lt;/li&gt;
&lt;li&gt;都包含抽象方法，其子类都必须覆写这些抽象方法&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;不同点&#34;&gt;不同点&lt;/h4&gt;
&lt;p&gt;&lt;img src=&#34;https://cheneycqg.github.io/post/javabasicinterviewquestions/5.jpg&#34;
	width=&#34;881&#34;
	height=&#34;411&#34;
	srcset=&#34;https://cheneycqg.github.io/post/javabasicinterviewquestions/5_hu61ef4caca0a239bd5e2ba4216966f8cb_52149_480x0_resize_q75_box.jpg 480w, https://cheneycqg.github.io/post/javabasicinterviewquestions/5_hu61ef4caca0a239bd5e2ba4216966f8cb_52149_1024x0_resize_q75_box.jpg 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;5&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;214&#34;
		data-flex-basis=&#34;514px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;备注：Java8中接口中引入默认方法和静态方法，以此来减少抽象类和接口之间的差异。&lt;/p&gt;
&lt;p&gt;现在，我们可以为接口提供默认实现的方法了，并且不用强制子类来实现它。&lt;/p&gt;
&lt;p&gt;接口和抽象类各有优缺点，在接口和抽象类的选择上，必须遵守这样一个原则：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;行为模型应该总是通过接口而不是抽象类定义，所以通常是优先选用接口，尽量少用抽象类。&lt;/li&gt;
&lt;li&gt;选择抽象类的时候通常是如下情况：需要定义子类的行为，又要为子类提供通用的功能。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;普通类和抽象类有哪些区别&#34;&gt;普通类和抽象类有哪些区别？&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;普通类不能包含抽象方法，抽象类可以包含抽象方法。&lt;/li&gt;
&lt;li&gt;抽象类不能直接实例化，普通类可以直接实例化。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;抽象类能使用-final-修饰吗&#34;&gt;抽象类能使用 final 修饰吗？&lt;/h4&gt;
&lt;p&gt;不能，定义抽象类就是让其他类继承的，如果定义为 final 该类就不能被继承，这样彼此就会产生矛盾，所以 final 不能修饰抽象类&lt;/p&gt;
&lt;h4 id=&#34;创建一个对象用什么关键字对象实例与对象引用有何不同&#34;&gt;创建一个对象用什么关键字？对象实例与对象引用有何不同？&lt;/h4&gt;
&lt;p&gt;new关键字，new创建对象实例（对象实例在堆内存中），对象引用指向对象实例（对象引用存放在栈内存中）。一个对象引用可以指向0个或1个对象（一根绳子可以不系气球，也可以系一个气球）;一个对象可以有n个引用指向它（可以用n条绳子系住一个气球）&lt;/p&gt;
&lt;h3 id=&#34;变量与方法&#34;&gt;变量与方法&lt;/h3&gt;
&lt;h4 id=&#34;成员变量与局部变量的区别有哪些&#34;&gt;成员变量与局部变量的区别有哪些&lt;/h4&gt;
&lt;p&gt;变量：在程序执行的过程中，在某个范围内其值可以发生改变的量。从本质上讲，变量其实是内存中的一小块区域&lt;/p&gt;
&lt;p&gt;成员变量：方法外部，类内部定义的变量&lt;/p&gt;
&lt;p&gt;局部变量：类的方法中的变量。&lt;/p&gt;
&lt;p&gt;成员变量和局部变量的区别&lt;/p&gt;
&lt;h5 id=&#34;作用域&#34;&gt;作用域&lt;/h5&gt;
&lt;p&gt;成员变量：针对整个类有效。&lt;/p&gt;
&lt;p&gt;局部变量：只在某个范围内有效。(一般指的就是方法,语句体内)&lt;/p&gt;
&lt;h5 id=&#34;存储位置&#34;&gt;存储位置&lt;/h5&gt;
&lt;p&gt;成员变量：随着对象的创建而存在，随着对象的消失而消失，存储在堆内存中。&lt;/p&gt;
&lt;p&gt;局部变量：在方法被调用，或者语句被执行的时候存在，存储在栈内存中。当方法调用完，或者语句结束后，就自动释放。&lt;/p&gt;
&lt;h5 id=&#34;生命周期&#34;&gt;生命周期&lt;/h5&gt;
&lt;p&gt;成员变量：随着对象的创建而存在，随着对象的消失而消失&lt;/p&gt;
&lt;p&gt;局部变量：当方法调用完，或者语句结束后，就自动释放。&lt;/p&gt;
&lt;h5 id=&#34;初始值&#34;&gt;初始值&lt;/h5&gt;
&lt;p&gt;成员变量：有默认初始值。&lt;/p&gt;
&lt;p&gt;局部变量：没有默认初始值，使用前必须赋值。&lt;/p&gt;
&lt;h5 id=&#34;使用原则&#34;&gt;使用原则&lt;/h5&gt;
&lt;p&gt;在使用变量时需要遵循的原则为：就近原则&lt;/p&gt;
&lt;p&gt;首先在局部范围找，有就使用；接着在成员位置找。&lt;/p&gt;
&lt;h4 id=&#34;在java中定义一个不做事且没有参数的构造方法的作用&#34;&gt;在Java中定义一个不做事且没有参数的构造方法的作用&lt;/h4&gt;
&lt;p&gt;Java程序在执行子类的构造方法之前，如果没有用super()来调用父类特定的构造方法，则会调用父类中“没有参数的构造方法”。因此，如果父类中只定义了有参数的构造方法，而在子类的构造方法中又没有用super()来调用父类中特定的构造方法，则编译时将发生错误，因为Java程序在父类中找不到没有参数的构造方法可供执行。解决办法是在父类里加上一个不做事且没有参数的构造方法。&lt;/p&gt;
&lt;h4 id=&#34;在调用子类构造方法之前会先调用父类没有参数的构造方法其目的是&#34;&gt;在调用子类构造方法之前会先调用父类没有参数的构造方法，其目的是？&lt;/h4&gt;
&lt;p&gt;帮助子类做初始化工作。&lt;/p&gt;
&lt;h4 id=&#34;一个类的构造方法的作用是什么若一个类没有声明构造方法改程序能正确执行吗为什么&#34;&gt;一个类的构造方法的作用是什么？若一个类没有声明构造方法，改程序能正确执行吗？为什么？&lt;/h4&gt;
&lt;p&gt;主要作用是完成对类对象的初始化工作。可以执行。因为一个类即使没有声明构造方法也会有默认的不带参数的构造方法。&lt;/p&gt;
&lt;h4 id=&#34;构造方法有哪些特性&#34;&gt;构造方法有哪些特性？&lt;/h4&gt;
&lt;p&gt;名字与类名相同；&lt;/p&gt;
&lt;p&gt;没有返回值，但不能用void声明构造函数；&lt;/p&gt;
&lt;p&gt;生成类的对象时自动执行，无需调用。&lt;/p&gt;
&lt;h4 id=&#34;静态变量和实例变量区别&#34;&gt;静态变量和实例变量区别&lt;/h4&gt;
&lt;p&gt;静态变量： 静态变量由于不属于任何实例对象，属于类的，所以在内存中只会有一份，在类的加载过程中，JVM只为静态变量分配一次内存空间。&lt;/p&gt;
&lt;p&gt;实例变量： 每次创建对象，都会为每个对象分配成员变量内存空间，实例变量是属于实例对象的，在内存中，创建几次对象，就有几份成员变量。&lt;/p&gt;
&lt;h4 id=&#34;静态变量与普通变量区别&#34;&gt;静态变量与普通变量区别&lt;/h4&gt;
&lt;p&gt;static变量也称作静态变量，静态变量和非静态变量的区别是：静态变量被所有的对象所共享，在内存中只有一个副本，它当且仅当在类初次加载时会被初始化。而非静态变量是对象所拥有的，在创建对象的时候被初始化，存在多个副本，各个对象拥有的副本互不影响。&lt;/p&gt;
&lt;p&gt;还有一点就是static成员变量的初始化顺序按照定义的顺序进行初始化。&lt;/p&gt;
&lt;h4 id=&#34;静态方法和实例方法有何不同&#34;&gt;静态方法和实例方法有何不同？&lt;/h4&gt;
&lt;p&gt;静态方法和实例方法的区别主要体现在两个方面：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;在外部调用静态方法时，可以使用&amp;quot;类名.方法名&amp;quot;的方式，也可以使用&amp;quot;对象名.方法名&amp;quot;的方式。而实例方法只有后面这种方式。也就是说，调用静态方法可以无需创建对象。&lt;/li&gt;
&lt;li&gt;静态方法在访问本类的成员时，只允许访问静态成员（即静态成员变量和静态方法），而不允许访问实例成员变量和实例方法；实例方法则无此限制&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;在一个静态方法内调用一个非静态成员为什么是非法的&#34;&gt;在一个静态方法内调用一个非静态成员为什么是非法的？&lt;/h4&gt;
&lt;p&gt;由于静态方法可以不通过对象进行调用，因此在静态方法里，不能调用其他非静态变量，也不可以访问非静态变量成员。&lt;/p&gt;
&lt;h4 id=&#34;什么是方法的返回值返回值的作用是什么&#34;&gt;什么是方法的返回值？返回值的作用是什么？&lt;/h4&gt;
&lt;p&gt;方法的返回值是指我们获取到的某个方法体中的代码执行后产生的结果！（前提是该方法可能产生结果）。返回值的作用:接收出结果，使得它可以用于其他的操作！&lt;/p&gt;
&lt;h3 id=&#34;内部类&#34;&gt;内部类&lt;/h3&gt;
&lt;h4 id=&#34;什么是内部类&#34;&gt;什么是内部类？&lt;/h4&gt;
&lt;p&gt;在Java中，可以将一个类的定义放在另外一个类的定义内部，这就是内部类。内部类本身就是类的一个属性，与其他属性定义方式一致。&lt;/p&gt;
&lt;h4 id=&#34;内部类的分类有哪些&#34;&gt;内部类的分类有哪些&lt;/h4&gt;
&lt;p&gt;内部类可以分为四种：成员内部类、局部内部类、匿名内部类和静态内部类。&lt;/p&gt;
&lt;h5 id=&#34;静态内部类&#34;&gt;静态内部类&lt;/h5&gt;
&lt;p&gt;定义在类内部的静态类，就是静态内部类。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Outer {

	private static int radius = 1;

	static class StaticInner {
    	public void visit() {
        	System.out.println(&amp;quot;visit outer static  variable:&amp;quot; + radius);
    	}
}}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;静态内部类可以访问外部类所有的静态变量，而不可访问外部类的非静态变量；静态内部类的创建方式，new 外部类.静态内部类()，如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Outer.StaticInner inner = new Outer.StaticInner();
inner.visit();
&lt;/code&gt;&lt;/pre&gt;
&lt;h5 id=&#34;成员内部类&#34;&gt;成员内部类&lt;/h5&gt;
&lt;p&gt;定义在类内部，成员位置上的非静态类，就是成员内部类。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Outer {

	private static  int radius = 1;
	private int count =2;

 	class Inner {
    	public void visit() {
        	System.out.println(&amp;quot;visit outer static  variable:&amp;quot; + radius);
        	System.out.println(&amp;quot;visit outer   variable:&amp;quot; + count);
    }
}}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;成员内部类可以访问外部类所有的变量和方法，包括静态和非静态，私有和公有。成员内部类依赖于外部类的实例，它的创建方式外部类实例.new 内部类()，如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Outer outer = new Outer();
Outer.Inner inner = outer.new Inner();
inner.visit();
&lt;/code&gt;&lt;/pre&gt;
&lt;h5 id=&#34;局部内部类&#34;&gt;局部内部类&lt;/h5&gt;
&lt;p&gt;定义在方法中的内部类，就是局部内部类。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Outer {
	private  int out_a = 1;
	private static int STATIC_b = 2;

	public void testFunctionClass(){
    	int inner_c =3;
    	class Inner {
        	private void fun(){
            	System.out.println(out_a);
            	System.out.println(STATIC_b);
            	System.out.println(inner_c);
        	}
    	}
    	Inner  inner = new Inner();
    	inner.fun();
	}
	public static void testStaticFunctionClass(){
    	int d =3;
    	class Inner {
        	private void fun(){
            	// System.out.println(out_a); 编译错误，定义在静态方法中的局部类不可以访问外部类的实例变量
            	System.out.println(STATIC_b);
            	System.out.println(d);
        	}
    	}
    	Inner  inner = new Inner();
    	inner.fun();
	}}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;定义在实例方法中的局部类可以访问外部类的所有变量和方法，定义在静态方法中的局部类只能访问外部类的静态变量和方法。局部内部类的创建方式，在对应方法内，new 内部类()，如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public static void testStaticFunctionClass(){
	class Inner {
	}
	Inner  inner = new Inner();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h5 id=&#34;匿名内部类&#34;&gt;匿名内部类&lt;/h5&gt;
&lt;p&gt;匿名内部类就是没有名字的内部类，日常开发中使用的比较多。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Outer {

	private void test(final int i) {
    	new Service() {
        	public void method() {
            	for (int j = 0; j &amp;lt; i; j++) {
                	System.out.println(&amp;quot;匿名内部类&amp;quot; );
            	}
        	}
    	}.method();
	}
}
//匿名内部类必须继承或实现一个已有的接口 
interface Service{
	void method();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;除了没有名字，匿名内部类还有以下特点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;匿名内部类必须继承一个抽象类或者实现一个接口。&lt;/li&gt;
&lt;li&gt;匿名内部类不能定义任何静态成员和静态方法。&lt;/li&gt;
&lt;li&gt;当所在的方法的形参需要被匿名内部类使用时，必须声明为 final。&lt;/li&gt;
&lt;li&gt;匿名内部类不能是抽象的，它必须要实现继承的类或者实现的接口的所有抽象方法。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;匿名内部类创建方式：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;new 类/接口{ 
	//匿名内部类实现部分
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;内部类的优点&#34;&gt;内部类的优点&lt;/h4&gt;
&lt;p&gt;我们为什么要使用内部类呢？因为它有以下优点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一个内部类对象可以访问创建它的外部类对象的内容，包括私有数据！&lt;/li&gt;
&lt;li&gt;内部类不为同一包的其他类所见，具有很好的封装性；&lt;/li&gt;
&lt;li&gt;内部类有效实现了“多重继承”，优化 java 单继承的缺陷。&lt;/li&gt;
&lt;li&gt;匿名内部类可以很方便的定义回调。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;内部类有哪些应用场景&#34;&gt;内部类有哪些应用场景&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;一些多算法场合&lt;/li&gt;
&lt;li&gt;解决一些非面向对象的语句块。&lt;/li&gt;
&lt;li&gt;适当使用内部类，使得代码更加灵活和富有扩展性。&lt;/li&gt;
&lt;li&gt;当某个类除了它的外部类，不再被其他的类使用时。&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;局部内部类和匿名内部类访问局部变量的时候为什么变量必须要加上final&#34;&gt;局部内部类和匿名内部类访问局部变量的时候，为什么变量必须要加上final？&lt;/h4&gt;
&lt;p&gt;局部内部类和匿名内部类访问局部变量的时候，为什么变量必须要加上final呢？它内部原理是什么呢？&lt;/p&gt;
&lt;p&gt;先看这段代码：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Outer {
	void outMethod(){
    	final int a =10;
    	class Inner {
        	void innerMethod(){
            	System.out.println(a);
        	}
    	}
}}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;以上例子，为什么要加final呢？是因为生命周期不一致， 局部变量直接存储在栈中，当方法执行结束后，非final的局部变量就被销毁。而局部内部类对局部变量的引用依然存在，如果局部内部类要调用局部变量时，就会出错。加了final，可以确保局部内部类使用的变量与外层的局部变量区分开，解决了这个问题。&lt;/p&gt;
&lt;h4 id=&#34;内部类相关看程序说出运行结果&#34;&gt;内部类相关，看程序说出运行结果&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;public class Outer {
private int age = 12;

class Inner {
    private int age = 13;
    public void print() {
        int age = 14;
        System.out.println(&amp;quot;局部变量：&amp;quot; + age);
        System.out.println(&amp;quot;内部类变量：&amp;quot; + this.age);
        System.out.println(&amp;quot;外部类变量：&amp;quot; + Outer.this.age);
    }
}

public static void main(String[] args) {
    Outer.Inner in = new Outer().new Inner();
    in.print();
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;运行结果：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;局部变量：14
内部类变量：13
外部类变量：12
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;重写与重载&#34;&gt;重写与重载&lt;/h3&gt;
&lt;h4 id=&#34;构造器constructor是否可被重写override&#34;&gt;构造器（constructor）是否可被重写（override）&lt;/h4&gt;
&lt;p&gt;构造器不能被继承，因此不能被重写，但可以被重载。&lt;/p&gt;
&lt;h4 id=&#34;重载overload和重写override的区别重载的方法能否根据返回类型进行区分&#34;&gt;重载（Overload）和重写（Override）的区别。重载的方法能否根据返回类型进行区分？&lt;/h4&gt;
&lt;p&gt;方法的重载和重写都是实现多态的方式，区别在于前者实现的是编译时的多态性，而后者实现的是运行时的多态性。&lt;/p&gt;
&lt;p&gt;重载：发生在同一个类中，方法名相同参数列表不同（参数类型不同、个数不同、顺序不同），与方法返回值和访问修饰符无关，即重载的方法不能根据返回类型进行区分&lt;/p&gt;
&lt;p&gt;重写：发生在父子类中，方法名、参数列表必须相同，返回值小于等于父类，抛出的异常小于等于父类，访问修饰符大于等于父类（里氏代换原则）；如果父类方法访问修饰符为private则子类中就不是重写。&lt;/p&gt;
&lt;h3 id=&#34;对象相等判断&#34;&gt;对象相等判断&lt;/h3&gt;
&lt;h4 id=&#34;-和-equals-的区别是什么&#34;&gt;== 和 equals 的区别是什么&lt;/h4&gt;
&lt;p&gt;== : 它的作用是判断两个对象的地址是不是相等。即，判断两个对象是不是同一个对象。(基本数据类型 == 比较的是值，引用数据类型 == 比较的是内存地址)&lt;/p&gt;
&lt;p&gt;equals() : 它的作用也是判断两个对象是否相等。但它一般有两种使用情况：&lt;/p&gt;
&lt;p&gt;情况1：类没有覆盖 equals() 方法。则通过 equals() 比较该类的两个对象时，等价于通过“==”比较这两个对象。&lt;/p&gt;
&lt;p&gt;情况2：类覆盖了 equals() 方法。一般，我们都覆盖 equals() 方法来两个对象的内容相等；若它们的内容相等，则返回 true (即，认为这两个对象相等)。&lt;/p&gt;
&lt;p&gt;举个例子：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class test1 {
public static void main(String[] args) {
    String a = new String(&amp;quot;ab&amp;quot;); // a 为一个引用
    String b = new String(&amp;quot;ab&amp;quot;); // b为另一个引用,对象的内容一样
    String aa = &amp;quot;ab&amp;quot;; // 放在常量池中
    String bb = &amp;quot;ab&amp;quot;; // 从常量池中查找
    if (aa == bb) // true
        System.out.println(&amp;quot;aa==bb&amp;quot;);
    if (a == b) // false，非同一对象
        System.out.println(&amp;quot;a==b&amp;quot;);
    if (a.equals(b)) // true
        System.out.println(&amp;quot;aEQb&amp;quot;);
    if (42 == 42.0) { // true
        System.out.println(&amp;quot;true&amp;quot;);
    }
}}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;说明：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;String中的equals方法是被重写过的，因为object的equals方法是比较的对象的内存地址，而String的equals方法比较的是对象的值。&lt;/li&gt;
&lt;li&gt;当创建String类型的对象时，虚拟机会在常量池中查找有没有已经存在的值和要创建的值相同的对象，如果有就把它赋给当前引用。如果没有就在常量池中重新创建一个String对象。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;hashcode-与-equals-重要&#34;&gt;hashCode 与 equals (重要)&lt;/h4&gt;
&lt;p&gt;HashSet如何检查重复&lt;/p&gt;
&lt;p&gt;两个对象的 hashCode() 相同，则 equals() 也一定为 true，对吗？
hashCode和equals方法的关系&lt;/p&gt;
&lt;p&gt;面试官可能会问你：“你重写过 hashcode 和 equals 么，为什么重写equals时必须重写hashCode方法？”&lt;/p&gt;
&lt;h4 id=&#34;hashcode介绍&#34;&gt;hashCode()介绍&lt;/h4&gt;
&lt;p&gt;hashCode() 的作用是获取哈希码，也称为散列码；它实际上是返回一个int整数。这个哈希码的作用是确定该对象在哈希表中的索引位置。&lt;/p&gt;
&lt;p&gt;hashCode() 定义在JDK的Object.java中，这就意味着Java中的任何类都包含有hashCode()函数。&lt;/p&gt;
&lt;p&gt;散列表存储的是键值对(key-value)，它的特点是：能根据“键”快速的检索出对应的“值”。这其中就利用到了散列码！（可以快速找到所需要的对象）&lt;/p&gt;
&lt;h4 id=&#34;为什么要有-hashcode&#34;&gt;为什么要有 hashCode&lt;/h4&gt;
&lt;h4 id=&#34;我们以hashset-如何检查重复为例子来说明为什么要有-hashcode&#34;&gt;我们以“HashSet 如何检查重复”为例子来说明为什么要有 hashCode：&lt;/h4&gt;
&lt;p&gt;当你把对象加入 HashSet 时，HashSet 会先计算对象的 hashcode 值来判断对象加入的位置，同时也会与其他已经加入的对象的 hashcode 值作比较，如果没有相符的hashcode，HashSet会假设对象没有重复出现。但是如果发现有相同 hashcode 值的对象，这时会调用 equals()方法来检查 hashcode 相等的对象是否真的相同。如果两者相同，HashSet 就不会让其加入操作成功。如果不同的话，就会重新散列到其他位置。（摘自我的Java启蒙书《Head first java》第二版）。这样我们就大大减少了 equals 的次数，相应就大大提高了执行速度。&lt;/p&gt;
&lt;h4 id=&#34;hashcode与equals的相关规定&#34;&gt;hashCode()与equals()的相关规定&lt;/h4&gt;
&lt;p&gt;如果两个对象相等，则hashcode一定也是相同的&lt;/p&gt;
&lt;p&gt;两个对象相等，对两个对象分别调用equals方法都返回true&lt;/p&gt;
&lt;p&gt;两个对象有相同的hashcode值，它们也不一定是相等的&lt;/p&gt;
&lt;h4 id=&#34;因此equals-方法被覆盖过则-hashcode-方法也必须被覆盖&#34;&gt;因此，equals 方法被覆盖过，则 hashCode 方法也必须被覆盖&lt;/h4&gt;
&lt;p&gt;hashCode() 的默认行为是对堆上的对象产生独特值。如果没有重写 hashCode()，则该 class 的两个对象无论如何都不会相等（即使这两个对象指向相同的数据）&lt;/p&gt;
&lt;h4 id=&#34;对象的相等与指向他们的引用相等两者有什么不同&#34;&gt;对象的相等与指向他们的引用相等，两者有什么不同？&lt;/h4&gt;
&lt;p&gt;对象的相等 比的是内存中存放的内容是否相等而&lt;/p&gt;
&lt;p&gt;引用相等 比较的是他们指向的内存地址是否相等。&lt;/p&gt;
&lt;h3 id=&#34;值传递&#34;&gt;值传递&lt;/h3&gt;
&lt;h4 id=&#34;当一个对象被当作参数传递到一个方法后此方法可改变这个对象的属性并可返回变化后的结果那么这里到底是值传递还是引用传递&#34;&gt;当一个对象被当作参数传递到一个方法后，此方法可改变这个对象的属性，并可返回变化后的结果，那么这里到底是值传递还是引用传递&lt;/h4&gt;
&lt;p&gt;是值传递。Java 语言的方法调用只支持参数的值传递。当一个对象实例作为一个参数被传递到方法中时，参数的值就是对该对象的引用。对象的属性可以在被调用过程中被改变，但对对象引用的改变是不会影响到调用者的&lt;/p&gt;
&lt;h4 id=&#34;为什么-java-中只有值传递&#34;&gt;为什么 Java 中只有值传递&lt;/h4&gt;
&lt;p&gt;首先回顾一下在程序设计语言中有关将参数传递给方法（或函数）的一些专业术语。按值调用(call by value)表示方法接收的是调用者提供的值，而按引用调用（call by reference)表示方法接收的是调用者提供的变量地址。一个方法可以修改传递引用所对应的变量值，而不能修改传递值调用所对应的变量值。 它用来描述各种程序设计语言（不只是Java)中方法参数传递方式&lt;/p&gt;
&lt;p&gt;Java程序设计语言总是采用按值调用。也就是说，方法得到的是所有参数值的一个拷贝，也就是说，方法不能修改传递给它的任何参数变量的内容。&lt;/p&gt;
&lt;p&gt;下面通过 3 个例子来给大家说明&lt;/p&gt;
&lt;p&gt;example 1&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public static void main(String[] args) {
	int num1 = 10;
	int num2 = 20;

	swap(num1, num2);

	System.out.println(&amp;quot;num1 = &amp;quot; + num1);
	System.out.println(&amp;quot;num2 = &amp;quot; + num2);}
public static void swap(int a, int b) {
	int temp = a;
	a = b;
	b = temp;

	System.out.println(&amp;quot;a = &amp;quot; + a);
	System.out.println(&amp;quot;b = &amp;quot; + b);}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;结果：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;a = 20
b = 10
num1 = 10
num2 = 20
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;解析：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cheneycqg.github.io/post/javabasicinterviewquestions/6.jpg&#34;
	width=&#34;484&#34;
	height=&#34;389&#34;
	srcset=&#34;https://cheneycqg.github.io/post/javabasicinterviewquestions/6_hu7f700ee998f07d0e585288766becc973_15262_480x0_resize_q75_box.jpg 480w, https://cheneycqg.github.io/post/javabasicinterviewquestions/6_hu7f700ee998f07d0e585288766becc973_15262_1024x0_resize_q75_box.jpg 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;6&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;124&#34;
		data-flex-basis=&#34;298px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;在swap方法中，a、b的值进行交换，并不会影响到 num1、num2。因为，a、b中的值，只是从 num1、num2 的复制过来的。也就是说，a、b相当于num1、num2 的副本，副本的内容无论怎么修改，都不会影响到原件本身。&lt;/p&gt;
&lt;p&gt;通过上面例子，我们已经知道了一个方法不能修改一个基本数据类型的参数，而对象引用作为参数就不一样，请看 example2.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public static void main(String[] args) {
    int[] arr = { 1, 2, 3, 4, 5 };
    System.out.println(arr[0]);
    change(arr);
    System.out.println(arr[0]);
}

public static void change(int[] array) {
    // 将数组的第一个元素变为0
    array[0] = 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;结果：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;1
0
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;解析：
&lt;img src=&#34;https://cheneycqg.github.io/post/javabasicinterviewquestions/7.jpg&#34;
	width=&#34;567&#34;
	height=&#34;308&#34;
	srcset=&#34;https://cheneycqg.github.io/post/javabasicinterviewquestions/7_hufd5099f1e08824835d45527bd9e08e41_13103_480x0_resize_q75_box.jpg 480w, https://cheneycqg.github.io/post/javabasicinterviewquestions/7_hufd5099f1e08824835d45527bd9e08e41_13103_1024x0_resize_q75_box.jpg 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;7&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;184&#34;
		data-flex-basis=&#34;441px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;array 被初始化 arr 的拷贝也就是一个对象的引用，也就是说 array 和 arr 指向的时同一个数组对象。 因此，外部对引用对象的改变会反映到所对应的对象上。&lt;/p&gt;
&lt;p&gt;通过 example2 我们已经看到，实现一个改变对象参数状态的方法并不是一件难事。理由很简单，方法得到的是对象引用的拷贝，对象引用及其他的拷贝同时引用同一个对象。&lt;/p&gt;
&lt;p&gt;很多程序设计语言（特别是，C++和Pascal)提供了两种参数传递的方式：值调用和引用调用。有些程序员（甚至本书的作者）认为Java程序设计语言对对象采用的是引用调用，实际上，这种理解是不对的。由于这种误解具有一定的普遍性，所以下面给出一个反例来详细地阐述一下这个问题。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;example 3
public class Test {

public static void main(String[] args) {
    // TODO Auto-generated method stub
    Student s1 = new Student(&amp;quot;小张&amp;quot;);
    Student s2 = new Student(&amp;quot;小李&amp;quot;);
    Test.swap(s1, s2);
    System.out.println(&amp;quot;s1:&amp;quot; + s1.getName());
    System.out.println(&amp;quot;s2:&amp;quot; + s2.getName());
}

public static void swap(Student x, Student y) {
    Student temp = x;
    x = y;
    y = temp;
    System.out.println(&amp;quot;x:&amp;quot; + x.getName());
    System.out.println(&amp;quot;y:&amp;quot; + y.getName());
}}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;结果：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;x:小李
y:小张
s1:小张
s2:小李
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;解析：&lt;/p&gt;
&lt;p&gt;交换之前：
&lt;img src=&#34;https://cheneycqg.github.io/post/javabasicinterviewquestions/8.jpg&#34;
	width=&#34;567&#34;
	height=&#34;291&#34;
	srcset=&#34;https://cheneycqg.github.io/post/javabasicinterviewquestions/8_hu388d825bff2fde189b893041644053e5_14354_480x0_resize_q75_box.jpg 480w, https://cheneycqg.github.io/post/javabasicinterviewquestions/8_hu388d825bff2fde189b893041644053e5_14354_1024x0_resize_q75_box.jpg 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;8&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;194&#34;
		data-flex-basis=&#34;467px&#34;
	
&gt;
交换之后：
&lt;img src=&#34;https://cheneycqg.github.io/post/javabasicinterviewquestions/9.jpg&#34;
	width=&#34;567&#34;
	height=&#34;291&#34;
	srcset=&#34;https://cheneycqg.github.io/post/javabasicinterviewquestions/9_hub368800e22f9680c3601fdede72b2d96_14569_480x0_resize_q75_box.jpg 480w, https://cheneycqg.github.io/post/javabasicinterviewquestions/9_hub368800e22f9680c3601fdede72b2d96_14569_1024x0_resize_q75_box.jpg 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;9&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;194&#34;
		data-flex-basis=&#34;467px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;通过上面两张图可以很清晰的看出： 方法并没有改变存储在变量 s1 和 s2 中的对象引用。swap方法的参数x和y被初始化为两个对象引用的拷贝，这个方法交换的是这两个拷贝&lt;/p&gt;
&lt;p&gt;总结
Java程序设计语言对对象采用的不是引用调用，实际上，对象引用是按值传递的。&lt;/p&gt;
&lt;p&gt;下面再总结一下Java中方法参数的使用情况：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一个方法不能修改一个基本数据类型的参数（即数值型或布尔型》&lt;/li&gt;
&lt;li&gt;一个方法可以改变一个对象参数的状态。&lt;/li&gt;
&lt;li&gt;一个方法不能让对象参数引用一个新的对象。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;值传递和引用传递有什么区别&#34;&gt;值传递和引用传递有什么区别&lt;/h4&gt;
&lt;p&gt;值传递：指的是在方法调用时，传递的参数是按值的拷贝传递，传递的是值的拷贝，也就是说传递后就互不相关了。&lt;/p&gt;
&lt;p&gt;引用传递：指的是在方法调用时，传递的参数是按引用进行传递，其实传递的引用的地址，也就是变量所对应的内存空间的地址。传递的是值的引用，也就是说传递前和传递后都指向同一个引用（也就是同一个内存空间）。&lt;/p&gt;
&lt;h3 id=&#34;java包&#34;&gt;Java包&lt;/h3&gt;
&lt;h4 id=&#34;jdk-中常用的包有哪些&#34;&gt;JDK 中常用的包有哪些&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;java.lang：这个是系统的基础类；&lt;/li&gt;
&lt;li&gt;java.io：这里面是所有输入输出有关的类，比如文件操作等；&lt;/li&gt;
&lt;li&gt;java.nio：为了完善 io 包中的功能，提高 io 包中性能而写的一个新包；&lt;/li&gt;
&lt;li&gt;java.net：这里面是与网络有关的类；&lt;/li&gt;
&lt;li&gt;java.util：这个是系统辅助类，特别是集合类；&lt;/li&gt;
&lt;li&gt;java.sql：这个是数据库操作的类。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;import-java和javax有什么区别&#34;&gt;import java和javax有什么区别&lt;/h4&gt;
&lt;p&gt;刚开始的时候 JavaAPI 所必需的包是 java 开头的包，javax 当时只是扩展 API 包来说使用。然而随着时间的推移，javax 逐渐的扩展成为 Java API 的组成部分。但是，将扩展从 javax 包移动到 java 包将是太麻烦了，最终会破坏一堆现有的代码。因此，最终决定 javax 包将成为标准API的一部分。&lt;/p&gt;
&lt;p&gt;所以，实际上java和javax没有区别。这都是一个名字。&lt;/p&gt;
&lt;h2 id=&#34;io流&#34;&gt;IO流&lt;/h2&gt;
&lt;h3 id=&#34;java中的io流分为几种&#34;&gt;Java中的IO流分为几种&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;按照流的流向分，可以分为输入流和输出流；&lt;/li&gt;
&lt;li&gt;按照操作单元划分，可以划分为字节流和字符流；&lt;/li&gt;
&lt;li&gt;按照流的角色划分为节点流和处理流。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Java Io流共涉及40多个类，这些类看上去很杂乱，但实际上很有规则，而且彼此之间存在非常紧密的联系， Java I0流的40多个类都是从如下4个抽象类基类中派生出来的。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;InputStream/Reader: 所有的输入流的基类，前者是字节输入流，后者是字符输入流。&lt;/li&gt;
&lt;li&gt;OutputStream/Writer: 所有输出流的基类，前者是字节输出流，后者是字符输出流。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;按操作方式分类结构图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cheneycqg.github.io/post/javabasicinterviewquestions/10.jpg&#34;
	width=&#34;567&#34;
	height=&#34;850&#34;
	srcset=&#34;https://cheneycqg.github.io/post/javabasicinterviewquestions/10_hu327fcc121cb688b32b5cfa4d0edc02ce_341013_480x0_resize_q75_box.jpg 480w, https://cheneycqg.github.io/post/javabasicinterviewquestions/10_hu327fcc121cb688b32b5cfa4d0edc02ce_341013_1024x0_resize_q75_box.jpg 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;10&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;66&#34;
		data-flex-basis=&#34;160px&#34;
	
&gt;
按操作对象分类结构图：
&lt;img src=&#34;https://cheneycqg.github.io/post/javabasicinterviewquestions/11.jpg&#34;
	width=&#34;567&#34;
	height=&#34;421&#34;
	srcset=&#34;https://cheneycqg.github.io/post/javabasicinterviewquestions/11_hu9ce5a9e76b405efc257401170f8f5677_224794_480x0_resize_q75_box.jpg 480w, https://cheneycqg.github.io/post/javabasicinterviewquestions/11_hu9ce5a9e76b405efc257401170f8f5677_224794_1024x0_resize_q75_box.jpg 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;11&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;134&#34;
		data-flex-basis=&#34;323px&#34;
	
&gt;&lt;/p&gt;
&lt;h3 id=&#34;bionioaio-有什么区别&#34;&gt;BIO,NIO,AIO 有什么区别?&lt;/h3&gt;
&lt;p&gt;简答&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;BIO：Block IO 同步阻塞式 IO，就是我们平常使用的传统 IO，它的特点是模式简单使用方便，并发处理能力低。&lt;/li&gt;
&lt;li&gt;NIO：Non IO 同步非阻塞 IO，是传统 IO 的升级，客户端和服务器端通过 Channel（通道）通讯，实现了多路复用。&lt;/li&gt;
&lt;li&gt;AIO：Asynchronous IO 是 NIO 的升级，也叫 NIO2，实现了异步非堵塞 IO ，异步 IO 的操作基于事件和回调机制。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;详细回答&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;BIO (Blocking I/O): 同步阻塞I/O模式，数据的读取写入必须阻塞在一个线程内等待其完成。在活动连接数不是特别高（小于单机1000）的情况下，这种模型是比较不错的，可以让每一个连接专注于自己的 I/O 并且编程模型简单，也不用过多考虑系统的过载、限流等问题。线程池本身就是一个天然的漏斗，可以缓冲一些系统处理不了的连接或请求。但是，当面对十万甚至百万级连接的时候，传统的 BIO 模型是无能为力的。因此，我们需要一种更高效的 I/O 处理模型来应对更高的并发量。&lt;/li&gt;
&lt;li&gt;NIO (New I/O): NIO是一种同步非阻塞的I/O模型，在Java 1.4 中引入了NIO框架，对应 java.nio 包，提供了 Channel , Selector，Buffer等抽象。NIO中的N可以理解为Non-blocking，不单纯是New。它支持面向缓冲的，基于通道的I/O操作方法。 NIO提供了与传统BIO模型中的 Socket 和 ServerSocket 相对应的 SocketChannel 和 ServerSocketChannel 两种不同的套接字通道实现,两种通道都支持阻塞和非阻塞两种模式。阻塞模式使用就像传统中的支持一样，比较简单，但是性能和可靠性都不好；非阻塞模式正好与之相反。对于低负载、低并发的应用程序，可以使用同步阻塞I/O来提升开发速率和更好的维护性；对于高负载、高并发的（网络）应用，应使用 NIO 的非阻塞模式来开发&lt;/li&gt;
&lt;li&gt;AIO (Asynchronous I/O): AIO 也就是 NIO 2。在 Java 7 中引入了 NIO 的改进版 NIO 2,它是异步非阻塞的IO模型。异步 IO 是基于事件和回调机制实现的，也就是应用操作之后会直接返回，不会堵塞在那里，当后台处理完成，操作系统会通知相应的线程进行后续的操作。AIO 是异步IO的缩写，虽然 NIO 在网络操作中，提供了非阻塞的方法，但是 NIO 的 IO 行为还是同步的。对于 NIO 来说，我们的业务线程是在 IO 操作准备好时，得到通知，接着就由这个线程自行进行 IO 操作，IO操作本身是同步的。查阅网上相关资料，我发现就目前来说 AIO 的应用还不是很广泛，Netty 之前也尝试使用过 AIO，不过又放弃了。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;files的常用方法都有哪些&#34;&gt;Files的常用方法都有哪些？&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;Files. exists()：检测文件路径是否存在。
Files. createFile()：创建文件。
Files. createDirectory()：创建文件夹。
Files. delete()：删除一个文件或目录。
Files. copy()：复制文件。
Files. move()：移动文件。
Files. size()：查看文件个数。
Files. read()：读取文件。
Files. write()：写入文件。
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;反射&#34;&gt;反射&lt;/h2&gt;
&lt;h3 id=&#34;什么是反射机制&#34;&gt;什么是反射机制&lt;/h3&gt;
&lt;p&gt;JAVA反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为java语言的反射机制。&lt;/p&gt;
&lt;p&gt;静态编译和动态编译&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;**静态编译：**在编译时确定类型，绑定对象&lt;/li&gt;
&lt;li&gt;**动态编译：**运行时确定类型，绑定对象&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;反射机制优缺点&#34;&gt;反射机制优缺点&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;优点：&lt;/strong&gt; 运行期类型的判断，动态加载类，提高代码灵活度。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;缺点：&lt;/strong&gt; 性能瓶颈：反射相当于一系列解释操作，通知 JVM 要做的事情，性能比直接的java代码要慢很多。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;反射机制的应用场景有哪些&#34;&gt;反射机制的应用场景有哪些&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;反射是框架设计的灵魂。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在我们平时的项目开发过程中，基本上很少会直接使用到反射机制，但这不能说明反射机制没有用，实际上有很多设计、开发都与反射机制有关，例如模块化的开发，通过反射去调用对应的字节码；动态代理设计模式也采用了反射机制，还有我们日常使用的 Spring／Hibernate 等框架也大量使用到了反射机制。&lt;/p&gt;
&lt;p&gt;举例：&lt;/p&gt;
&lt;p&gt;①我们在使用JDBC连接数据库时使用Class.forName()通过反射加载数据库的驱动程序；&lt;/p&gt;
&lt;p&gt;②Spring框架也用到很多反射机制，最经典的就是xml的配置模式。Spring 通过 XML 配置模式装载 Bean 的过程：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;将程序内所有 XML 或 Properties 配置文件加载入内存中;&lt;/li&gt;
&lt;li&gt;Java类里面解析xml或properties里面的内容，得到对应实体类的字节码字符串以及相关的属性信息;&lt;/li&gt;
&lt;li&gt;使用反射机制，根据这个字符串获得某个类的Class实例;&lt;/li&gt;
&lt;li&gt;动态配置实例的属性&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;java获取反射的三种方法&#34;&gt;Java获取反射的三种方法&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;通过new对象实现反射机制&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;通过路径实现反射机制&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;通过类名实现反射机制&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; public class Student {
 	private int id;
 	String name;
 	protected boolean sex;
 	public float score;
 }

 public class Get {
 	//获取反射机制三种方式
 	public static void main(String[] args) throws ClassNotFoundException {
 		//方式一(通过建立对象)
 		Student stu = new Student();
 		Class classobj1 = stu.getClass();
 		System.out.println(classobj1.getName());
 		//方式二（所在通过路径-相对路径）
 		Class classobj2 = Class.forName(&amp;quot;fanshe.Student&amp;quot;);
 		System.out.println(classobj2.getName());
 		//方式三（通过类名）
 		Class classobj3 = Student.class;
 		System.out.println(classobj3.getName());
 }}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;常用api&#34;&gt;常用API&lt;/h2&gt;
&lt;h3 id=&#34;string相关&#34;&gt;String相关&lt;/h3&gt;
&lt;h4 id=&#34;字符型常量和字符串常量的区别&#34;&gt;字符型常量和字符串常量的区别&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;形式上: 字符常量是单引号引起的一个字符 字符串常量是双引号引起的若干个字符&lt;/li&gt;
&lt;li&gt;含义上: 字符常量相当于一个整形值(ASCII值),可以参加表达式运算 字符串常量代表一个地址值(该字符串在内存中存放位置)&lt;/li&gt;
&lt;li&gt;占内存大小 字符常量只占一个字节 字符串常量占若干个字节(至少一个字符结束标志)&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;什么是字符串常量池&#34;&gt;什么是字符串常量池？&lt;/h4&gt;
&lt;p&gt;字符串常量池位于堆内存中，专门用来存储字符串常量，可以提高内存的使用率，避免开辟多块空间存储相同的字符串，在创建字符串时 JVM 会首先检查字符串常量池，如果该字符串已经存在池中，则返回它的引用，如果不存在，则实例化一个字符串放到池中，并返回其引用。&lt;/p&gt;
&lt;h4 id=&#34;string-是最基本的数据类型吗&#34;&gt;String 是最基本的数据类型吗&lt;/h4&gt;
&lt;p&gt;不是。Java 中的基本数据类型只有 8 个 ：byte、short、int、long、float、double、char、boolean；除了基本类型（primitive type），剩下的都是引用类型（referencetype），Java 5 以后引入的枚举类型也算是一种比较特殊的引用类型。&lt;/p&gt;
&lt;p&gt;这是很基础的东西，但是很多初学者却容易忽视，Java 的 8 种基本数据类型中不包括 String，基本数据类型中用来描述文本数据的是 char，但是它只能表示单个字符，比如 ‘a’,‘好’ 之类的，如果要描述一段文本，就需要用多个 char 类型的变量，也就是一个 char 类型数组，比如“你好” 就是长度为2的数组 char[] chars = {‘你’,‘好’};
但是使用数组过于麻烦，&lt;strong&gt;所以就有了 String，String 底层就是一个 char 类型的数组，只是使用的时候开发者不需要直接操作底层数组，用更加简便的方式即可完成对字符串的使用。&lt;/strong&gt;&lt;/p&gt;
&lt;h4 id=&#34;string有哪些特性&#34;&gt;String有哪些特性&lt;/h4&gt;
&lt;p&gt;**不变性：**String 是只读字符串，是一个典型的 immutable 对象，对它进行任何操作，其实都是创建一个新的对象，再把引用指向该对象。不变模式的主要作用在于当一个对象需要被多线程共享并频繁访问时，可以保证数据的一致性。
**常量池优化：**String 对象创建之后，会在字符串常量池中进行缓存，如果下次创建同样的对象时，会直接返回缓存的引用。
**final：**使用 final 来定义 String 类，表示 String 类不能被继承，提高了系统的安全性。&lt;/p&gt;
&lt;h4 id=&#34;string为什么是不可变的吗&#34;&gt;String为什么是不可变的吗？&lt;/h4&gt;
&lt;p&gt;简单来说就是String类利用了final修饰的char类型数组存储字符，源码如下图所以：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;/** The value is used for character storage. */private final char value[];
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;string真的是不可变的吗&#34;&gt;String真的是不可变的吗？&lt;/h4&gt;
&lt;p&gt;我觉得如果别人问这个问题的话，回答不可变就可以了。 下面只是给大家看两个有代表性的例子：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1) String不可变但不代表引用不可以变&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;	String str = &amp;quot;Hello&amp;quot;;
	str = str + &amp;quot; World&amp;quot;;
	System.out.println(&amp;quot;str=&amp;quot; + str);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;结果：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;	str=Hello World
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;解析：&lt;/p&gt;
&lt;p&gt;实际上，原来String的内容是不变的，只是str由原来指向&amp;quot;Hello&amp;quot;的内存地址转为指向&amp;quot;Hello World&amp;quot;的内存地址而已，也就是说多开辟了一块内存区域给&amp;quot;Hello World&amp;quot;字符串。
&lt;strong&gt;2) 通过反射是可以修改所谓的“不可变”对象&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;	// 创建字符串&amp;quot;Hello World&amp;quot;， 并赋给引用s
	String s = &amp;quot;Hello World&amp;quot;;

	System.out.println(&amp;quot;s = &amp;quot; + s); // Hello World
	// 获取String类中的value字段
	Field valueFieldOfString = String.class.getDeclaredField(&amp;quot;value&amp;quot;);
	// 改变value属性的访问权限
	valueFieldOfString.setAccessible(true);
	// 获取s对象上的value属性的值char[] value = (char[]) valueFieldOfString.get(s);
	// 改变value所引用的数组中的第5个字符
	value[5] = &#39;_&#39;;

	System.out.println(&amp;quot;s = &amp;quot; + s); // Hello_World
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;结果：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;	s = Hello World
	s = Hello_World
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;解析：&lt;/p&gt;
&lt;p&gt;用反射可以访问私有成员， 然后反射出String对象中的value属性， 进而改变通过获得的value引用改变数组的结构。但是一般我们不会这么做，这里只是简单提一下有这个东西。&lt;/p&gt;
&lt;h4 id=&#34;是否可以继承-string-类&#34;&gt;是否可以继承 String 类&lt;/h4&gt;
&lt;p&gt;String 类是 final 类，不可以被继承。&lt;/p&gt;
&lt;h4 id=&#34;string-stri与-string-strnew-stringi一样吗&#34;&gt;String str=&amp;ldquo;i&amp;quot;与 String str=new String(“i”)一样吗？&lt;/h4&gt;
&lt;p&gt;不一样，因为内存的分配方式不一样。String str=&amp;ldquo;i&amp;quot;的方式，java 虚拟机会将其分配到常量池中；而 String str=new String(“i”) 则会被分到堆内存中。&lt;/p&gt;
&lt;h4 id=&#34;string-s--new-stringxyz创建了几个字符串对象&#34;&gt;String s = new String(“xyz”);创建了几个字符串对象&lt;/h4&gt;
&lt;p&gt;两个对象，一个是静态区的&amp;quot;xyz&amp;rdquo;，一个是用new创建在堆上的对象。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;	String str1 = &amp;quot;hello&amp;quot;; //str1指向静态区
	String str2 = new String(&amp;quot;hello&amp;quot;);  //str2指向堆上的对象
	String str3 = &amp;quot;hello&amp;quot;;
	String str4 = new String(&amp;quot;hello&amp;quot;);
	System.out.println(str1.equals(str2)); //true
	System.out.println(str2.equals(str4)); //true
	System.out.println(str1 == str3); //true
	System.out.println(str1 == str2); //false
	System.out.println(str2 == str4); //false
	System.out.println(str2 == &amp;quot;hello&amp;quot;); //false
	str2 = str1;
	System.out.println(str2 == &amp;quot;hello&amp;quot;); //true
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;如何将字符串反转&#34;&gt;如何将字符串反转？&lt;/h4&gt;
&lt;p&gt;使用 StringBuilder 或者 stringBuffer 的 reverse() 方法。
示例代码：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;	// StringBuffer reverse
	StringBuffer stringBuffer = new StringBuffer();
	stringBuffer. append(&amp;quot;abcdefg&amp;quot;);
	System. out. println(stringBuffer. reverse()); // gfedcba
	// StringBuilder reverse
	StringBuilder stringBuilder = new StringBuilder();
	stringBuilder. append(&amp;quot;abcdefg&amp;quot;);
	System. out. println(stringBuilder. reverse()); // gfedcba
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;数组有没有-length方法string-有没有-length方法&#34;&gt;数组有没有 length()方法？String 有没有 length()方法&lt;/h4&gt;
&lt;p&gt;数组没有 length()方法 ，有 length 的属性。&lt;/p&gt;
&lt;p&gt;String 有 length()方法。JavaScript中，获得字符串的长度是通过 length 属性得到的，这一点容易和 Java 混淆。&lt;/p&gt;
&lt;h4 id=&#34;string-类的常用方法都有那些&#34;&gt;String 类的常用方法都有那些？&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;	indexOf()：返回指定字符的索引。
	charAt()：返回指定索引处的字符。
	replace()：字符串替换。
	trim()：去除字符串两端空白。
	split()：分割字符串，返回一个分割后的字符串数组。
	getBytes()：返回字符串的 byte 类型数组。
	length()：返回字符串长度。
	toLowerCase()：将字符串转成小写字母。
	toUpperCase()：将字符串转成大写字符。
	substring()：截取字符串。
	equals()：字符串比较。
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;在使用-hashmap-的时候用-string-做-key-有什么好处&#34;&gt;在使用 HashMap 的时候，用 String 做 key 有什么好处？&lt;/h4&gt;
&lt;p&gt;HashMap 内部实现是通过 key 的 hashcode 来确定 value 的存储位置，因为字符串是不可变的，所以当创建字符串时，它的 hashcode 被缓存下来，不需要再次计算，所以相比于其他对象更快。&lt;/p&gt;
&lt;h4 id=&#34;string和stringbufferstringbuilder的区别是什么string为什么是不可变的&#34;&gt;String和StringBuffer、StringBuilder的区别是什么？String为什么是不可变的&lt;/h4&gt;
&lt;h5 id=&#34;可变性&#34;&gt;可变性&lt;/h5&gt;
&lt;p&gt;String类中使用字符数组保存字符串，private　final　char　value[]，所以string对象是不可变的。StringBuilder与StringBuffer都继承自AbstractStringBuilder类，在AbstractStringBuilder中也是使用字符数组保存字符串，char[] value，这两种对象都是可变的。&lt;/p&gt;
&lt;h5 id=&#34;线程安全性&#34;&gt;线程安全性&lt;/h5&gt;
&lt;p&gt;String中的对象是不可变的，也就可以理解为常量，线程安全。&lt;/p&gt;
&lt;p&gt;AbstractStringBuilder是StringBuilder与StringBuffer的公共父类，定义了一些字符串的基本操作，如expandCapacity、append、insert、indexOf等公共方法。&lt;/p&gt;
&lt;p&gt;StringBuffer对方法加了同步锁或者对调用的方法加了同步锁，所以是线程安全的。&lt;/p&gt;
&lt;p&gt;StringBuilder并没有对方法进行加同步锁，所以是非线程安全的。&lt;/p&gt;
&lt;h5 id=&#34;性能&#34;&gt;性能&lt;/h5&gt;
&lt;p&gt;每次对String 类型进行改变的时候，都会生成一个新的String对象，然后将指针指向新的String 对象。&lt;/p&gt;
&lt;p&gt;StringBuffer每次都会对StringBuffer对象本身进行操作，而不是生成新的对象并改变对象引用。相同情况下使用StirngBuilder 相比使用StringBuffer 仅能获得10%~15% 左右的性能提升，但却要冒多线程不安全的风险。&lt;/p&gt;
&lt;h5 id=&#34;对于三者使用的总结&#34;&gt;对于三者使用的总结&lt;/h5&gt;
&lt;p&gt;如果要操作少量的数据用 = String&lt;/p&gt;
&lt;p&gt;单线程操作字符串缓冲区 下操作大量数据 = StringBuilder&lt;/p&gt;
&lt;p&gt;多线程操作字符串缓冲区 下操作大量数据 = StringBuffer&lt;/p&gt;
&lt;h3 id=&#34;包装类相关&#34;&gt;包装类相关&lt;/h3&gt;
&lt;h4 id=&#34;自动装箱与拆箱&#34;&gt;自动装箱与拆箱&lt;/h4&gt;
&lt;p&gt;**装箱：**将基本类型用它们对应的引用类型包装起来；&lt;/p&gt;
&lt;p&gt;**拆箱：**将包装类型转换为基本数据类型；&lt;/p&gt;
&lt;h4 id=&#34;int-和-integer-有什么区别&#34;&gt;int 和 Integer 有什么区别&lt;/h4&gt;
&lt;p&gt;Java 是一个近乎纯洁的面向对象编程语言，但是为了编程的方便还是引入了基本数据类型，但是为了能够将这些基本数据类型当成对象操作，Java 为每一个基本数据类型都引入了对应的包装类型（wrapper class），int 的包装类就是 Integer，从 Java 5 开始引入了自动装箱/拆箱机制，使得二者可以相互转换。&lt;/p&gt;
&lt;p&gt;Java 为每个原始类型提供了包装类型：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;原始类型:&lt;/strong&gt; boolean，char，byte，short，int，long，float，double&lt;/p&gt;
&lt;p&gt;**包装类型：**Boolean，Character，Byte，Short，Integer，Long，Float，Double&lt;/p&gt;
&lt;h4 id=&#34;integer-a-127-与-integer-b--127相等吗&#34;&gt;Integer a= 127 与 Integer b = 127相等吗&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;对于对象引用类型：&lt;/strong&gt;==比较的是对象的内存地址。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;对于基本数据类型：&lt;/strong&gt;==比较的是值。&lt;/p&gt;
&lt;p&gt;如果整型字面量的值在-128到127之间，那么自动装箱时不会new新的Integer对象，而是直接引用常量池中的Integer对象，超过范围 a1==b1的结果是false&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;	public static void main(String[] args) {
		Integer a = new Integer(3);
		Integer b = 3;  // 将3自动装箱成Integer类型
		int c = 3;
		System.out.println(a == b); // false 两个引用没有引用同一对象
		System.out.println(a == c); // true a自动拆箱成int类型再和c比较
		System.out.println(b == c); // true

		Integer a1 = 128;
		Integer b1 = 128;
		System.out.println(a1 == b1); // false

		Integer a2 = 127;
		Integer b2 = 127;
		System.out.println(a2 == b2); // true
	}&lt;/code&gt;&lt;/pre&gt;</description>
        </item>
        <item>
        <title>SpringBoot项目Validation组件&#43;全局异常处理进行各种参数验证问题</title>
        <link>https://cheneycqg.github.io/post/validation/</link>
        <pubDate>Sun, 06 Aug 2023 00:00:00 +0000</pubDate>
        
        <guid>https://cheneycqg.github.io/post/validation/</guid>
        <description>&lt;img src="https://cheneycqg.github.io/post/validation/1.jpg" alt="Featured image of post SpringBoot项目Validation组件&#43;全局异常处理进行各种参数验证问题" /&gt;&lt;p&gt;SpringBoot项目Validation组件+全局异常处理进行各种参数验证问题，比如，写登录模块各种条件的判断等等&lt;/p&gt;
&lt;h1 id=&#34;springboot&#34;&gt;SpringBoot&lt;/h1&gt;
&lt;h2 id=&#34;为什么要使用validation组件和valid进行参数验证&#34;&gt;为什么要使用Validation组件和@Valid进行参数验证&lt;/h2&gt;
&lt;p&gt;SpringBoot项目中，会经常写接口类，比如：登录或者注册模块会有大量的校验工作。在写接口时经常要写效验请求参数逻辑，这时候我们会常用做法是写大量的 if 与 if else 类似这样的代码来做判断，如下：
&lt;img src=&#34;https://cheneycqg.github.io/post/validation/2.jpg&#34;
	width=&#34;1049&#34;
	height=&#34;261&#34;
	srcset=&#34;https://cheneycqg.github.io/post/validation/2_hufe4874d73f05ef0d0987cf6aad4786d8_31961_480x0_resize_q75_box.jpg 480w, https://cheneycqg.github.io/post/validation/2_hufe4874d73f05ef0d0987cf6aad4786d8_31961_1024x0_resize_q75_box.jpg 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;2&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;401&#34;
		data-flex-basis=&#34;964px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;这样的代码如果按正常代码逻辑来说，是没有什么问题的，不过按优雅来说，简直糟糕透了。不仅不优雅，而且如果存在大量的验证逻辑，这会使代码看起来乱糟糟，大大降低代码可读性，那么有没有更好的方法能够简化这个过程呢？&lt;/p&gt;
&lt;p&gt;答案当然是有，推荐的是使用 @Valid 注解来帮助我们简化验证逻辑。&lt;/p&gt;
&lt;h2 id=&#34;valid的相关注解&#34;&gt;@Valid的相关注解&lt;/h2&gt;
&lt;p&gt;下面是 @Valid 相关的注解，在实体类中不同的属性上添加不同的注解，就能实现不同数据的效验功能。
&lt;img src=&#34;https://cheneycqg.github.io/post/validation/3.png&#34;
	width=&#34;681&#34;
	height=&#34;549&#34;
	srcset=&#34;https://cheneycqg.github.io/post/validation/3_hub013f0394bfe45497f19d50c43878bfa_80449_480x0_resize_box_3.png 480w, https://cheneycqg.github.io/post/validation/3_hub013f0394bfe45497f19d50c43878bfa_80449_1024x0_resize_box_3.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;3&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;124&#34;
		data-flex-basis=&#34;297px&#34;
	
&gt;&lt;/p&gt;
&lt;h2 id=&#34;使用valid进行参数校验步骤&#34;&gt;使用@Valid进行参数校验步骤&lt;/h2&gt;
&lt;p&gt;整个过程如下图所示，用户访问接口，然后进行参数效验，因为 @Valid 不支持平面的参数效验（直接写在参数中字段的效验）所以基于 GET 请求的参数还是按照原先方式进行效验，而 POST 则可以以实体对象为参数，可以使用 @Valid 方式进行效验。如果效验通过，则进入业务逻辑，否则抛出异常，交由全局异常处理器进行处理。&lt;/p&gt;
&lt;h2 id=&#34;springboot实战&#34;&gt;SpringBoot实战&lt;/h2&gt;
&lt;h3 id=&#34;valid&#34;&gt;@Valid&lt;/h3&gt;
&lt;h4 id=&#34;实体类&#34;&gt;实体类&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;	package com.cheney.seckill.vo;

	import com.cheney.seckill.validation.IsMobile;
	import lombok.AllArgsConstructor;
	import lombok.Data;
	import lombok.NoArgsConstructor;
	import org.hibernate.validator.constraints.Length;

	import javax.validation.constraints.NotNull;

	@Data
	@AllArgsConstructor
	@NoArgsConstructor
	public class LoginVo {

		@IsMobile(require = true)
		private String mobile;
		@NotNull
		@Length(min = 32,max = 32)
		private String password;
	}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;controller&#34;&gt;Controller&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;	@Controller
	@RequestMapping(&amp;quot;/login&amp;quot;)
	public class LoginController {
		@Autowired
		private IUserService iUserService;
		@RequestMapping(&amp;quot;/toLogin&amp;quot;)
		public String toLogin(){
    		return &amp;quot;login&amp;quot;;
		}
	@RequestMapping(&amp;quot;/doLogin&amp;quot;)
	@ResponseBody
	public RespBean doLogin(@Valid LoginVo loginVo, HttpServletRequest request, HttpServletResponse response) throws InterruptedException {
    	RespBean respBean = iUserService.doLogin(loginVo,request,response);
    	Thread.sleep(2000);
    	return respBean;
		}
	}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;注意： 形参上必须要加@Valid注解&lt;/p&gt;
&lt;h4 id=&#34;进行测试&#34;&gt;进行测试&lt;/h4&gt;
&lt;h3 id=&#34;自定义校验&#34;&gt;自定义校验&lt;/h3&gt;
&lt;h4 id=&#34;引入validation组件依赖&#34;&gt;引入validation组件依赖&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;!-- validation组件 --&amp;gt; 
&amp;lt;dependency&amp;gt;
	&amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
	&amp;lt;artifactId&amp;gt;spring-boot-starter-validation&amp;lt;/artifactId&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;自定义校验注解&#34;&gt;自定义校验注解&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;/**
* 验证手机号
*/
@Target({METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER, TYPE_USE})
@Retention(RUNTIME)
@Documented
@Constraint(validatedBy = {IsMobileValidator.class})
public @interface IsMobile {
   boolean required() default true;
   String message() default &amp;quot;手机号码格式错误&amp;quot;;
   Class&amp;lt;?&amp;gt;[] groups() default {};
   Class&amp;lt;? extends Payload&amp;gt;[] payload() default {};
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;自定义校验注解的校验器&#34;&gt;自定义校验注解的校验器&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;/**
 * 自定义IsMobile注解的校验器
 */
public class IsMobileValidator implements ConstraintValidator&amp;lt;IsMobile,String&amp;gt; {
	private boolean require;
	@Override
	public void initialize(IsMobile constraintAnnotation) {
		require = constraintAnnotation.require();
	}

	@Override
	public boolean isValid(String s, ConstraintValidatorContext constraintValidatorContext) {
		//判断require是否符合手机格式
		if (StringUtils.isEmpty(s)){
			if (require)
			//手机号为空。要求必填
				return false;
			else
			//手机号为空，但是我也不要求必填
				return true;
		}else {
			//1手机号不为空
			return ValidatorUtil.isMobile(s);
		}
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;自定义校验规则&#34;&gt;自定义校验规则&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;/**
* 校验工具类
*/
public class ValidatorUtil {
	private static final Pattern mobile_pattern = Pattern.compile(&amp;quot;[1]([3-9])[0-9]{9}$&amp;quot;);
    public static boolean isMobile(String mobile){
  		if (StringUtils.isEmpty(mobile)) {
 			return false;
  		}
  		Matcher matcher = mobile_pattern.matcher(mobile);
  		return matcher.matches();
   }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;异常处理&#34;&gt;异常处理&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;我们知道，系统中异常包括：编译时异常和运行时异常 RuntimeException ，前者通过捕获异常从而获 取异常信息，后者主要通过规范代码开发、测试通过手段减少运行时异常的发生。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在开发中，不管是 dao层、service层还是controller层，都有可能抛出异常，在Springmvc中，能将所有类型的异常处理,从各处理过程解耦出来，既保证了相关处理过程的功能较单一，也实现了异常信息的统一处理和维护。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;SpringBoot全局异常处理方式主要两种：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使用 @ControllerAdvice 和 @ExceptionHandler 注解。&lt;/li&gt;
&lt;li&gt;使用 ErrorController类 来实现&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;区别：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;@ControllerAdvice 方式只能处理控制器抛出的异常。此时请求已经进入控制器中。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;ErrorController类 方式可以处理所有的异常，包括未进入控制器的错误，比如404,401等错误&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果应用中两者共同存在，则 @ControllerAdvice 方式处理控制器抛出的异常,ErrorController类 方式处理未进入控制器的异常。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;@ControllerAdvice 方式可以定义多个拦截方法，拦截不同的异常类，并且可以获取抛出的异常 信息，自由度更大。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;globalexception&#34;&gt;&lt;strong&gt;GlobalException&lt;/strong&gt;&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;/**
 * 自定义全局异常
 * 我们抛出的所有异常都是该异常
 */
@Data
@AllArgsConstructor
@NoArgsConstructor
public class GlobalException extends RuntimeException{
	private RespBeanEnum respBeanEnum;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;globalexceptionhandler&#34;&gt;&lt;strong&gt;GlobalExceptionHandler&lt;/strong&gt;&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;/**
 * 全局异常处理器
 */
@RestControllerAdvice
public class GlobalExceptionHandler {
@ExceptionHandler(value = Exception.class)
public RespBean handler(Exception e) throws Exception {
	//将异常转换为RespBean对象
	//异常有很多种。可能是自己的异常，可能是系统的等等
	if (e instanceof GlobalException){
		GlobalException ge = (GlobalException) e;
		return RespBean.error(ge.getRespBeanEnum());
	}else if (e instanceof BindException){
		BindException be = (BindException) e;
		String msg = be.getBindingResult().getAllErrors().get(0).getDefaultMessage();
		return new RespBean(500502L,msg,null);
	}else {
		//throw e;
		return RespBean.error(RespBeanEnum.ERROR);
	}
}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这样就可以省去各种健壮性判断，并且通过全局异常来前端异常提示，而不是一个异常页面。但是对开发中调试bug不太友好，因为没有异常信息。&lt;/p&gt;</description>
        </item>
        <item>
        <title>ObjectMapper不要一直new啦！！！</title>
        <link>https://cheneycqg.github.io/post/objectmapper/</link>
        <pubDate>Fri, 04 Aug 2023 00:00:00 +0000</pubDate>
        
        <guid>https://cheneycqg.github.io/post/objectmapper/</guid>
        <description>&lt;img src="https://cheneycqg.github.io/post/objectmapper/pawel-czerwinski-8uZPynIu-rQ-unsplash.png" alt="Featured image of post ObjectMapper不要一直new啦！！！" /&gt;&lt;p&gt; 很多同学发现，jackson并没有类似fastjson的&lt;code&gt;JSON.parseObjec&lt;/code&gt;这样的，确实看起来很快的方法。要想解析json，你不得不new一个ObjectMapper，来处理真正的解析动作。&lt;/p&gt;
&lt;h2 id=&#34;jackson&#34;&gt;Jackson&lt;/h2&gt;
&lt;p&gt;​		 自从国产之光fastjson频频暴雷，jackson json的使用是越来越广泛了。尤其是spring家族把它搞成了默认的JSON处理包，jackson的使用数量更是呈爆炸式发展。&lt;/p&gt;
&lt;p&gt;​		 很多同学发现，jackson并没有类似fastjson的&lt;code&gt;JSON.parseObjec&lt;/code&gt;这样的，确实看起来很快的方法。要想解析json，你不得不new一个ObjectMapper，来处理真正的解析动作。&lt;/p&gt;
&lt;p&gt;就像下面这样。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; String &lt;span style=&#34;color:#a6e22e&#34;&gt;getCarString&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;Car car&lt;span style=&#34;color:#f92672&#34;&gt;){&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    ObjectMapper objectMapper &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; ObjectMapper&lt;span style=&#34;color:#f92672&#34;&gt;();&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    String str &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; objectMapper&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;writeValueAsString&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;car&lt;span style=&#34;color:#f92672&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; str&lt;span style=&#34;color:#f92672&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;这代码有问题吗&#34;&gt;这代码有问题吗？&lt;/h2&gt;
&lt;p&gt;你要说它有问题，它确实能正确的执行。你要说它没问题，在追求性能的同学眼里，这肯定是一段十恶不赦的代码。&lt;/p&gt;
&lt;p&gt;一般的工具类，都是单例的，同时是线程安全的。ObjectMapper也不例外，它也是线程安全的，你可以并发的执行它，不会产生任何问题。&lt;/p&gt;
&lt;p&gt;这段代码，ObjectMapper在每次方法调用的时候，都会生成一个。那它除了造成一定的年轻代内存浪费之外，在执行时间上有没有什么硬伤呢？&lt;/p&gt;
&lt;p&gt;new和不new，真的区别有那么大么？&lt;/p&gt;
&lt;p&gt;有一次，xjjdog隐晦的指出某段被频繁调用的代码问题，被小伙伴怒吼着拿出证据。&lt;/p&gt;
&lt;p&gt;证据？这得搬出Java中的基准测试工具JMH，才能一探究竟。&lt;/p&gt;
&lt;p&gt;​		 JMH(the Java Microbenchmark Harness) 就是这样一个能够做基准测试的工具。如果你通过我们一系列的工具，定位到了热点代码，要测试它的性能数据，评估改善情况，就可以交给JMH。它的测量精度非常高，最高可达到纳秒的级别。&lt;/p&gt;
&lt;p&gt;​		 &lt;code&gt;	JMH&lt;/code&gt;是一个jar包，它和单元测试框架&lt;code&gt;JUnit&lt;/code&gt;非常的像，可以通过注解进行一些基础配置。这部分配置有很多是可以通过main方法的&lt;code&gt;OptionsBuilder&lt;/code&gt;进行设置的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cheneycqg.github.io/post/objectmapper/20230804134753.png&#34;
	width=&#34;834&#34;
	height=&#34;506&#34;
	srcset=&#34;https://cheneycqg.github.io/post/objectmapper/20230804134753_huc5252033c061ef1e45400dff536dfa60_150063_480x0_resize_box_3.png 480w, https://cheneycqg.github.io/post/objectmapper/20230804134753_huc5252033c061ef1e45400dff536dfa60_150063_1024x0_resize_box_3.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;图片&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;164&#34;
		data-flex-basis=&#34;395px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;​		 上图是一个典型的JMH程序执行的内容。通过开启多个进程，多个线程，首先执行预热，然后执行迭代，最后汇总所有的测试数据进行分析。在执行前后，还可以根据粒度处理一些前置和后置操作。&lt;/p&gt;
&lt;h2 id=&#34;jmh测试结果&#34;&gt;JMH测试结果&lt;/h2&gt;
&lt;p&gt;为了测试上面的场景，我们创造了下面的基准测试类。分为三个测试场景：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;直接在方法里new ObjectMapper&lt;/li&gt;
&lt;li&gt;在全局共享一个ObjectMapper&lt;/li&gt;
&lt;li&gt;使用ThreadLocal，每个线程一个ObjectMapper&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这样的测试属于cpu密集型的。我的cpu有10核，直接就分配了10个线程的并发，cpu在测试期间跑的满满的。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;@BenchmarkMode&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;({&lt;/span&gt;Mode&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;Throughput&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;})&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;@OutputTimeUnit&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;TimeUnit&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;SECONDS&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;@State&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;Scope&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;Thread&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;@Warmup&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;iterations &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;5&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;,&lt;/span&gt; time &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;,&lt;/span&gt; timeUnit &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; TimeUnit&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;SECONDS&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;@Measurement&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;iterations &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;5&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;,&lt;/span&gt; time &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;,&lt;/span&gt; timeUnit &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; TimeUnit&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;SECONDS&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;@Fork&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;@Threads&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;ObjectMapperTest&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    String json &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;{ \&amp;#34;color\&amp;#34; : \&amp;#34;Black\&amp;#34;, \&amp;#34;type\&amp;#34; : \&amp;#34;BMW\&amp;#34; }&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;@State&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;Scope&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;Benchmark&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;BenchmarkState&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        ObjectMapper GLOBAL_MAP &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; ObjectMapper&lt;span style=&#34;color:#f92672&#34;&gt;();&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        ThreadLocal&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;ObjectMapper&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; GLOBAL_MAP_THREAD &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; ThreadLocal&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;gt;();&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;@Benchmark&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; Map &lt;span style=&#34;color:#a6e22e&#34;&gt;globalTest&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;BenchmarkState state&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;throws&lt;/span&gt; Exception&lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        Map map &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; state&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;GLOBAL_MAP&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;readValue&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;json&lt;span style=&#34;color:#f92672&#34;&gt;,&lt;/span&gt; Map&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;class&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; map&lt;span style=&#34;color:#f92672&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;@Benchmark&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; Map &lt;span style=&#34;color:#a6e22e&#34;&gt;globalTestThreadLocal&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;BenchmarkState state&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;throws&lt;/span&gt; Exception&lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;null&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; state&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;GLOBAL_MAP_THREAD&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;get&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;()){&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            state&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;GLOBAL_MAP_THREAD&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;set&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; ObjectMapper&lt;span style=&#34;color:#f92672&#34;&gt;());&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        Map map &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; state&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;GLOBAL_MAP_THREAD&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;get&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;().&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;readValue&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;json&lt;span style=&#34;color:#f92672&#34;&gt;,&lt;/span&gt; Map&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;class&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; map&lt;span style=&#34;color:#f92672&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;@Benchmark&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; Map &lt;span style=&#34;color:#a6e22e&#34;&gt;localTest&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;()&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;throws&lt;/span&gt; Exception&lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        ObjectMapper objectMapper &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; ObjectMapper&lt;span style=&#34;color:#f92672&#34;&gt;();&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        Map map &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; objectMapper&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;readValue&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;json&lt;span style=&#34;color:#f92672&#34;&gt;,&lt;/span&gt; Map&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;class&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; map&lt;span style=&#34;color:#f92672&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;main&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;String&lt;span style=&#34;color:#f92672&#34;&gt;[]&lt;/span&gt; args&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;throws&lt;/span&gt; Exception &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        Options opts &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; OptionsBuilder&lt;span style=&#34;color:#f92672&#34;&gt;()&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                &lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;include&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;ObjectMapperTest&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;class&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;getSimpleName&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;())&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                &lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;resultFormat&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;ResultFormatType&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;CSV&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                &lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;build&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;();&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; Runner&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;opts&lt;span style=&#34;color:#f92672&#34;&gt;).&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;run&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;();&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;测试结果如下。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;Benchmark                                Mode  Cnt         Score         Error  Units
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;ObjectMapperTest&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;globalTest&lt;/span&gt;             thrpt    &lt;span style=&#34;color:#ae81ff&#34;&gt;5&lt;/span&gt;  &lt;span style=&#34;color:#ae81ff&#34;&gt;25125094.559&lt;/span&gt; &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;±&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1754308.010&lt;/span&gt;  ops&lt;span style=&#34;color:#f92672&#34;&gt;/&lt;/span&gt;s
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;ObjectMapperTest&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;globalTestThreadLocal&lt;/span&gt;  thrpt    &lt;span style=&#34;color:#ae81ff&#34;&gt;5&lt;/span&gt;  &lt;span style=&#34;color:#ae81ff&#34;&gt;31780573.549&lt;/span&gt; &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;±&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;7779240.155&lt;/span&gt;  ops&lt;span style=&#34;color:#f92672&#34;&gt;/&lt;/span&gt;s
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;ObjectMapperTest&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;localTest&lt;/span&gt;              thrpt    &lt;span style=&#34;color:#ae81ff&#34;&gt;5&lt;/span&gt;   &lt;span style=&#34;color:#ae81ff&#34;&gt;2131394.345&lt;/span&gt; &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;±&lt;/span&gt;  &lt;span style=&#34;color:#ae81ff&#34;&gt;216974.682&lt;/span&gt;  ops&lt;span style=&#34;color:#f92672&#34;&gt;/&lt;/span&gt;s
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;​		 从测试结果可以看出，如果我们每次调用都new一个ObjectMapper，每秒可以执行200万次JSON解析；如果全局使用一个ObjectMapper，则每秒可以执行2000多万次，速度足足快了10倍。&lt;/p&gt;
&lt;p&gt;如果使用ThreadLocal的方式，每个线程给它分配一个解析器，则性能会有少许上升，但也没有达到非常夸张的地步。&lt;/p&gt;
&lt;p&gt;所以在项目中写代码的时候，我们只需要保证有一个全局的ObjectMapper就可以了。&lt;/p&gt;
&lt;p&gt;​		 当然，由于ObjectMapper有很多的特性需要配置，你可能会为不同的应用场景分配一个单独使用的ObjectMapper。总之，它的数量不需要太多，因为它是线程安全的。&lt;/p&gt;
&lt;h2 id=&#34;总结&#34;&gt;总结&lt;/h2&gt;
&lt;p&gt;​		 所以结论就比较清晰了，我们只需要在整个项目里使用一个ObjectMapper就可以了，没必要傻不拉几的每次都new一个，毕竟性能差了10倍。如果你的JSON有很多自定义的配置，使用全局的变量更能凸显它的优势。&lt;/p&gt;
&lt;p&gt;​		 不要觉得这样做没有必要，保持良好的编码习惯永远是好的。高性能的代码都是点点滴滴积累起来的。不积跬步,无以至千里。不积小流,无以成江海，说的就是这个道理。&lt;/p&gt;</description>
        </item>
        
    </channel>
</rss>
